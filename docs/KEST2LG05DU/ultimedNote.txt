"""

MEANING OF THINGS

	!!! = important

	# = command

	## = interesting

	### = options

	in terminal = in linux terminal

	{} = contents of a specific thing

	syntax = syntax

"""

### -r = is most often recursiv


chapter 1{
	key terms{
		
		bash
			Bourne Again SHell - an sh-compatible command language interpreter that executes commands read from the standard input or from a file.
			Section 1.3.1 
		ls
			Command that will list information about files. The current directory is listed by default.
			Section 1.3.1 

	}
}

chapter 2{
	uname{

		Short Option 			Long Option 			Prints
		-a			 	--all 				All information
		-s 				--kernel-name  			Kernel name
		-n 				--node-name 			Network node name
		-r 				--kernel-release 		Kernel release
		-v 				--kernel-version 		Kernel version
		-m 				--machine 			Machine hardware name
		-p 				--processor 			Processor type or unknown
		-i 				--hardware-platform 		Hardware platform or unknown
		-o 				--operating-system 		Operating system
						--help 				Help information
						--version 			Version information
	}

	man{
		Command 			Function
		Return (or Enter) 		Go down one line
		Space 				Go down one page
		/term 				Search for term
		n 				Find next search item
		1G 				Go to the beginning of the page
		G 				Go to the end of the page
		h 				Display help
		q 				Quit man page
	}

	key terms{
		
		Quoting
			Enclosing special characters in quotes will prevent the shell from interpreting special characters. Double quotes will prevent the shell from interpreting some of these special characters; single quotes prevent the shell from interpreting any special characters.
			Section 2.3.1.1 
		echo
			Echo the STRING(s) to standard output. Useful with scripts.
			Section 2.3.1.1 
		man
			An interface to the on-line reference manuals.
			Section 2.9 | Section 2.9.1 | Section 2.9.2 | Section 2.9.3 | Section 2.9.4 | Section 2.9.5 | Section 2.9.6 | Section 2.9.6.1 | Section 2.9.6.2 | Section 2.9.6.3 | Section 2.9.6.4 
		pwd
			Print the name of the current working directory.
			Section 2.6 
		uname
			Print certain system information such as kernel name, network node hostname, kernel release, kernel version, machine hardware name, processor type, hardware platform, and operating system, depending on options provided.
			Section 2.5 

	}
}

chapter 3{
	key terms{
		
		.bash_history
			File used to store the current history list when the shell is closed.
			Section 3.4 
		env
			Print a list of the current Environment variables or change to an alternate environment.
			Section 3.2.1 
		export
			Makes an assigned variable available to sub-processes.
			Section 3.2.1 
		history
			Print a list of previously executed commands or "re-execute" previously executed commands.
			Section 3.4 
		set
			Display all variables (local and environment).
			Section 3.2.2 
		unset
			Remove one or more variables.
			Section 3.2.3 

	}
}

chapter 4{
	key terms{
		
		file globbing
			The glob function searches for all the pathnames matching pattern according to the rules used by the shell. ( * , ? , [] , )
			Section 4.1 | Section 4.2 | Section 4.3 | Section 4.4 

	}
}

chapter 5{
	key terms{

		cp
			Command used to copy files and directories. cp will copy a SOURCE to a DEST, or multiple SOURCES to a DIRECTORY.
			Section 5.5 
		file
			Command used to determine the type of file. file tests each argument in an attempt to classify it. There are three sets of tests, preformed in this order: filesystem test, magic tests, and language tests.
			Section 5.3 
		ls
			Command that will list information about files. The current directory is listed by default.
			| Section 5.2 
		mkdir
			Command used to create directories, if they do not already exist.
			Section 5.8 
		rm
			Command used to remove files or directories. By default the rm command will not remove directories.
			Section 5.7 
		rmdir
			Command that is used to remove empty directories in the filesystem.
			Section 5.9 
		touch
			Command used to change the file timestamps. touch will allow a user to update the access and modification times of each FILE to the current time.
			Section 5.4 

	}
}

chapter 6{
	key terms{
		
		/etc/updatedb.conf
			A configuration file for the updatedb utility. In some implementations, updatedb.conf is a shell script that allows more flexibility in defining variables
			Section 6.3.1 
		find
			Command used to search for files in a directory hierarchy. find searches the directory tree rooted at each given file name by evaluating the given the expression from left to right.
			Section 6.3.2 
		locate
			Command used to search for files by name. locate reads one or more databases prepared by the updatedb utility and writes file names matching at least one of the PATTERNs to standard output.
			Section 6.3.1 
		type
			Command that indicates how a name would be interpreted if used as a command. When using the type utility, the path to the command will be displayed.
			Section 6.3.5 
		updatedb
			The updatedb utility creates or updates a database to be used by the locate utility.
			Section 6.3.1 
		whereis
			Command that is used to locate source/binary and manuals sections for specified rules. This will locate binary, source, and manual pages for a command.
			Section 6.3.3 
		which
			Command that returns the pathnames of the files, or links, which would be executed in the current environment. It does this by searching the PATH for executables matching the names of the arguments.
			Section 6.3.4 

	}
}

chapter 7{
	key terms{
		
		cat
			Displays the contents of one or more files (concatenate) to standard output.
			Section 7.2 
		cut
			Command used to extract fields of information from a text file.
			Section 7.9 
		head
			Prints the first ten lines of a file by default. The number of lines can be set to any desired value.
			Section 7.5 
		less
			Pager command used to view file contents one page of data at a time.
			Section 7.2 
		nl
			Prepend a number to the lines of a file incrementing each line by 1 by default.
			Section 7.4 
		od
			Performs an octal dump of data by default. Often used to display the contents of files with non-printable characters.
			Section 7.12 
		paste
			Merge the lines of one or more files, line by line, separating the output by tabs by default.
			Section 7.7 
		sed
			A non-interactive editor that can be used to modify text.
			Section 7.14 
		sort
			Command used to display a file sorted on a specific field of data.
			Section 7.9 
		split
			Command used to take one file and break it into multiple parts. By default it breaks the file up into 1000 line sections.
			Section 7.3 
		tail
			Prints the last ten lines of a file by default. The number of lines can be set to any desired value.
			Section 7.6 
		tr
			Command used to translate one set of characters to another.
			Section 7.13 
		uniq
			Command to remove duplicate lines that are currently consecutive.
			Section 7.11 
		wc
			Print newline, word, and byte counts for each FILE, and a total line if more than one FILE is specified.
			Section 7.15 

	}
}

chapter 8{
	key terms{
		
		egrep
			Command that performs the same function as grep -E. This command has been deprecated, but is around for historical applications.
			Section 8.3 | Section 8.7 
		fgrep
			Command that performs the same function grep -F. This command has been deprecated, but is around for historical applications.
			Section 8.6 
		grep
			Command used ot print lines matching a specific pattern. grep searches the named input FILE for lines containing a match to a given PATTERN.
			Section 8.1 
		regex(7)
			Regular expression. This is a term used to describe a codified method of searching for text ,or other strings in text.
			Section 8.1 
		sed
			A non-interactive editor that can be used to modify text.
			| Section 8.4 

	}
}

chapter 9{

	# vi is a editor

	key terms{
		
		/, ?
			This is used to search for text while in command mode. the / is used to start searching. Enter a key term and press enter to begin searching the file for the text entered. If the user would like to search backwards in the document, a ? can be used instead of the /.
			Section 9.3 
		EDITOR

			Section 9.6 
		ZZ, :w!, :q!
			These keys are used to exit the vi editor from command mode. ZZ is used to save and quit the file. It must be done for each file. :w! will force the writing of the current file. :q! will exit the editor without saving changes to the current file.
			Section 9.5 
		d, p, y, dd, yy
			These are used to copy, replace and paste text when in command mode. d is used to cut one alphabetic word, where as dd is used to cut an entire line of text. y is used to copy one one alphabetic word, where as yy is used to copy and entire line at a time. If a number precedes either dd or yy, this will copy that number of lines. For example if 3dd is typed this will cut 3 lines at a time.
			Section 9.3 
		h,j,k,l
			These keys are used for basic cursor movement in vi when in command mode. h moves left one character, j moves down one line, k moves up one line, and l moves right one character.
			Section 9.2 
		i, o, a
			i, o, and a are used to enter insert mode from command mode. i will allow a user to start inserting text at the current location of the cursor. o will allow a user to start inserting text a line below the current location of the cursor, and a will allow a user to insert text one postion after the current location of the cursor.
			Section 9.4 
		vi
			A screen-oriented text editor originally created for Unix operating systems. vi is also known as a modal editor in which the user must switch modes to create, edit, and search text in a file.
			Section 9.1 | Section 9.2 | Section 9.3 | Section 9.4 | Section 9.5 

	}
}

chapter 10{
	key terms{
		
		tee
			Command used to read from standard input and write to standard output and files.
			Section 10.6 
		xargs
			Command used to build and execute command lines from standard input.
			Section 10.7 

	}
}


chapter 11{
	ps
	{ 
		ps[OPTION]...   # The ps command can be used to list processes
				# The ps command supports three styles of options{
					Traditonal UNIX style short options that use a single hyphens[-] in front of a character
					GNU style long options that use two hyphens[-] in front of a word
					BSD style options that use no hyphens[-] and single character options
				}
				# The ps command will display the processes that are running in the current terminal by default

			#ps Columns info{
				PID : The process identifier, witch is unique to the process. This info is useful to control the process by its ID number
				TTY : The name of the terminal ir pseudo-terminal where the process us running. This ifno is useful to distinguish between differebt processes that have the same name
				TIME : The total amount of processor time used by the process. Typically, this info int't used by regular users.
				CMD : The command that started the process.
			}

			# ps x [BSD option] state {
				D : Uninterruptible Sleep
				R : Running
				S : Interruptible Sleep
				T : Stopped
				Z : Zombie
			}

			# ps aux [BSD option] {
				a : Allows the ps command to show all processes
				u : Show processes by all users and ignore restrictions to only list the user's processes
				x : List all processes and remove the restriction to only display
			}# it shows everything

			in terminal{
				ps aux | grep -i sshd # To find all processes that match the sshd string
			}
	}

	pgrep
	{
		in terminal {
			pgrep -i sshd # If you wanted to find all instances of the sshd

			pgrep -li sshd # The output shows the process IDs (PID) of the processes running that match the sshd string. Additionally, the -l option can be used with the pgrep command to list the process name along with the PID

			# It is also possible to search for processes owned by a specific user by using the -u option

			pgrep -u sysadmin -l # the -u and -l options displayed the bash process which has the PID 56 and is owned by the sysadmin user.
		}

	}

	watch
	{
		syntax{ 
			watch [OPTION]... COMMAND
		}
		# The watch command can be use with date for a good test
		# The watch command can also be used with the ps command to monitor running processes in the shell
		in terminal {
			watch ps aux
		}
	}

	## To write a couple of command in one line use the semicolon [ ; ]


	Background Processes
	{
		COMMAND & 
		
		in terminal{
			sleep 3 & # this runs in the Background
		}
	}

	kill
	{
		syntax of kill command{
			kill [OPTION]... <pid>
		}

		### specifying signals for kill command {
			-<signal>
			-s <signal>
			--signal <signal>

			example for interrupt signal{
				-2
				-INT
				-SIGINT
			}
		}


		in terminal{
			kill -l # To see a list of all of the signals available for your system
 		}
		

		common signals{
			number : full name : short name : purpose
			1      : SIGHUB    :  HUP       : Hang up, usually ends a process
			2      : SIGINT    :  INT       : Interrupt, usually ends a process
			3      : SIGQUIT   :  QUIT      : Quit, usually ends a process
			9      : SIGKILL   :  KILL      : Kill, forcefully ends a process
			15     : SIGTERM   :  TERM      : Terminate, usually ends a process
			18     : SIGCONT   :  CONT      : Continue, resumes a stopped process
			19     : SIGSTOP   :  STOP      : Stop, forcefully stops a process
			20     : SIGTSTP   :  TSTP      : Terminal Stop, usually stops a process
		}
	}
	
	pkill{
		syntax{
			pkill [OPTION]... PATTERN
		}
		
		# the pkill command allows users to specify a pattern that matches a process name and then sends signals to that process
	}
	
	killall{
		syntax{
			killall [OPTION]... NAME
		}

		in terminal{
			killall sleep
		}

		# The killall command can also be used to terminate one or more processes by name and other criteria such as the user owner of the process and system processes.
	}

	# top is like the task manager

	key terms{ 
		&
			When used with a process will immediately background the process or task in a terminal. This will allow the terminal to be freed up for additional tasks.
			Section 11.2.6 

		bg
			A job control command that resumes the execution of a suspended process without bringing it to the foreground.
			Section 11.2.7 

		fg
			A job control command that resumes execution of a suspended process by bringing it to the foreground.
			Section 11.2.7 

		free
			Command used to display the amount of free and used memory in the system. This utility will display both the physical and swap memore on the system as well as the buffers used by the kernel.
			Section 11.2.3 | Section 11.3 

		jobs
			Command that lists all active jobs in the current terminal or shell.
			Section 11.2.6 

		kill
			Command used to terminate a process. There are specific signals that can terminate a process in different ways. If no signal is provided the TERM signal will be sent to the process.
			Section 11.2.8 

		killall
			Command similar to kill, but killall will allow a user to terminate a process by name as opposed to ID.
			Section 11.2.8 

		nice
			Command used to change the priority of a process. The higher the nice value the lower the priority of a process. Nice values range from -20 to 20.
			Section 11.2.10 

		nohup
			Command used to run a command immune to hangups, with output to a non-tty. If standard input is a terminal, it can be redirected from /dev/null. If standard output is the terminal, append the ouptput to nohup.out. This should be located in the user's home directory.
			Section 11.2.9 

		pgrep
			Command that parses through the running processes and looks for the specified names or other criteria of processes.
			Section 11.2.2 

		pkill
			Sends a specified signal (SIGTERM by default) to each process instead of listing them on stdout.
			Section 11.2.8 

		ps
			Command used to report a snapshot of the current processes. Different options are available with ps to report more specific information.
			Section 11.2.1 

		renice
			Command used to change the priority of a process while that process is running. The higher the value the lower the priority.
			Section 11.2.10 

		screen
			A full-screen software program that can be used to multiplex a physical console between several processes (typically interactive shells). It offers a user to open several separate terminal instances inside a one single terminal window manager. The screen application is very useful, if you are dealing with multiple programs from a command line interface and for separating programs from the terminal shell. It also allows you to share your sessions with others users and detach/attach terminal sessions.
			Section 11.4.1 

		tmux

			Section 11.4.2 

		top
			Command similar to ps, however top will display the curent real-time view of all running tasks and processes.
			Section 11.2.11 

		uptime
			Command that will display how long a system has been running. uptime gives a one line display showing the current time, how long ths system has been running, how many users are logged in, and the system load averages for the pas 1, 5 and 15 minutes.
			Section 11.3 
			
		watch

			Section 11.2.3 
	}

}


chapter 12{
	# Archiving: Combines multiple files into one, which eliminates the overhead in individual files and makes it easier to transmit.

	#Compression: Makes the files smaller by removing redundant information
	
	gzip and gunzip{
		# The gzip command is used to create a compressed file. Likewise, the gunzip command is used to view the contents of a compressed file, as well as extract those contents.
		
		syntax{
			gzip [OPTION]... [FILE]...
			gunzip [OPTION]... [FILE]...
		}

		# gzip2 compresses
		# gunzip2 uncompresses

		!!! The gzip command should be used with caution since its default behavior is to replace the original file specified with a compressed version.
	}

	zcat{
		# The zcat command is used to display the contents of a compressed file without actually uncompressing it

		syntax{
			zcat [OPTION]... [FILE]...
		}
	}

	bzip2 and bunzip2{
		#The bzip2 and bunzip2 commands work in a nearly identical fashion to the gzip and gunzip commands. However, while the gzip command uses the Lempel-Ziv data compression algorithm, the bzip utilities use a different compression algorithm called Burrows-Wheeler block sorting, that can compress files smaller than gzip at the expense of more CPU time
	
		syntax{
			bzip2 [OPTION]... [FILE]...
			bunzip2 [OPTION]... [FILE]...
		}

		# bzip2 compresses
		# bunzip2 uncompresses

		!!! The bzip2 command should be used with caution since its default behavior is to replace the original file specified with a compressed version.

		!!! ### -r recursion dose not work with bzip2 and bunzip2

		### The -v option gives a verbose output so you can see how the file was processed
	}

	bzcat{
		# The bzcat command prints the content of specified files compressed with the bzip2 command to the standard output.

		syntax{
			bzcat [OPTION]... [FILE]...
		}
	}

	xz and unxz{
		# Another archival tool similar to gzip and bzip2 is the xz command.
		### To compress a group of files individually, use the xz command with the -z option. Compression is the default operation mode, and therefore if the xz command is run with no options, the -z option is implied.

		syntax{
			xz [OPTION]... [FILE]...
		}

		### The -d option can be used with the xz command to uncompress the files just as easily

		# Another method of uncompressing files compressed using the xz command is to use the unxz command. Using unxz to uncompress a file is very similar to using gunzip because it uses similar syntax.
	
		!!! There are a huge number of options for the xz command, some relating to the compression ratio. Keep in mind when using xz that the more aggressive the compression, the harder the processor will have to work.
	}

	xzcat{
		# The xzcat command is used to print the contents of files compressed with the xz command to standard output on the terminal without uncompressing the target file.

		syntax{
			xzcat [FILE]...
		}
	}

	tar{
		## The tar command is typically used to make archives within Linux. These tar archive files, sometimes called tarballs, were originally used to backup data onto magnetic tape. Tar is derived from the words "tape archive".

		# While the primary purpose of the tar command is to merge multiple files into a single file, it is capable of many different operations, and there are numerous options

			tar functionalitys{
				
				### Create = -c # Make a new archive out of a series of files.

				### Extract = -x # Pull one or more files out of an archive.

				### List = -t # Show the contents of the archive without extracting.

			}

		Create Mode{

			syntax{
				tar -c [-f ARCHIVE] [OPTIONS] [FILE...]
			}

			### -c = create an archive.
			
			### -f ARCHIVE = Use the ARCHIVE file. The argument ARCHIVE will be the name of the resulting archive file.

			## All the remaining arguments, [FILE…], are considered as input file names either as a list of files, as a wildcard, or both.

			in terminal{
				tar -cf mydocuments.tar ~/Documents
			}
			
			### -v = Verbosely list the files processed.
			
			### -z = Compress (or decompress) the archive using the gzip command.

			### -j = Filter the archive through the bzip2 command

			### -J = Filter the archive through the xz command.

			## File extensions are not relevant to Linux; however, it is customary to add .tar.gz to the name of the compressed archive. 

			in terminal{
				tar -cvzf mydocuments.tar.gz ~/Documents
			}

		}

		List Mode{
			
			syntax{
				tar -t [-f ARCHIVE] [OPTIONS]
			}

			### -t = List the files in the archive. (table of contents)

			### -f ARCHIVE = Operate on the given archive. 

			in terminal{
				tar -tf mydocuments.tar.gz
			}

			## note that the -f option is used last so that the file name can be specified as an argument to this option

			in terminal{
				# you can add the verbose (-v) to get a more detailed output

				tar -tvf mydocuments.tar.gz
			}

		}

		Extract Mode{

			syntax{
				tar -x [-f ARCHIVE] [OPTIONS]
			}

			### -x = Extract files from an archive.

			### -f ARCHIVE = Operate on the given archive.

		}
	}

	zip and unzip{

		syntax{
			zip [OPTIONS]... [FILE]...
		}

		### One especially useful option for the zip command is the -r option, which allows the zip command to recursively compress

		# The unzip command is used to extract the files from the zip archive file. Use the unzip command without options to extract a zip archive

		### To view the contents of a zip file without unpacking it, use the unzip command with the list -l option:
	}

	cpio{
		## In copy-out mode, the cpio command will copy files from a directory into an archive.

		## In copy-out mode, the cpio command will copy files from a directory into an archive.

		## There is a third mode called the copy-pass mode. In this mode, the cpio command copies files from one directory to another, which combines the copy-out and copy-in modes without creating an archive file.
	
		Copy-Out Mode{
			### The -o option puts the cpio command into copy-out mode

			### Using the verbose -v option will cause the cpio command to list the files that it processes

			in terminal {
				ls | cpio -ov > archive.cpio
			}

			find command{

				in terminal{
					find . -depth -print | cpio -vo > /tmp/ar.cpio
				}

			}
		}

		Copy-In Mode{

			### To extract the files that are in a cpio archive, use the -i option with the cpio command to specify copy-in mode

			### By default, cpio will not overwrite existing files unless the -u option is used.

			!!! ### The cpio command will not create directories unless the -d option is used.

			in terminal{

				cpio -idv /tmp/test < /tmp/ar.cpio

				find ~ | cpio -pd /tmp/destination

			}

			## To specify the pass-through mode of the cpio command, specify the -p option. Again, if any directories are included, the -d option needs to be specified

			## To prevent problems with files that have white space characters (like the spacebar character) embedded in them, specify the -print0 option to the find command

			## For the cpio command to process the list of null separated files, add the --null option. This results in a more robust version of the previous pass-through command

			in terminal{
				find . -print0 | cpio --null -pvd /tmp/destination
			}

		}
	}

	dd{
		# The dd command is a utility for copying files or entire partitions at the bit level

		dd features{
			
			It can be used to clone or delete (wipe) entire disks or partitions.
			
			It can be used to copy raw data to removable devices, such as USB drives and CDROMs.
			
			It can backup and restore the MBR (Master Boot Record), a critical software component that is used to boot the system.
			
			It can be used to create a file of a specific size that is filled with binary zeros, which can then be used as a swap file (virtual memory).

		}

		dd commonly used special arguments{
			if=FILE : The input file to be read.
			of=FILE : The output file to be written.
			bs=SIZE : The block size to be used. By default, the value is considered to be in bytes. Use the following suffixes to specify other units: K, M, G, and T for kilobytes, megabytes, gigabytes, and terabytes respectively.
			count=NUMBERS : The number of blocks to read from the input file.
		}

		in terminal{
			# In the following example, a file named /tmp/swapex is created with 500 "one-megabyte" size blocks of zeros:

			dd if=/dev/zero of=/tmp/swapex bs=1M count=500
		}

	}

	key terms{
		
		bunzip2
			Command that uncompresses files compressed using the <command>bzip2</command> command and removes the .bz2 extension.
			Section 12.4 
		bzcat
			Command prints the content of specified files compressed with the <command>bzip2</command> command to the standard output.
			Section 12.5 
		gunzip
			Command that decompress files created by gzip, zip, compress, compress -H or pack.
			Section 12.2 
		gzip
			Command used to comperess or expand files. Gzip reduces the size of the named files using Lempel-Ziv coding (LZ77). Whenever possible, each file is replaced by one with the extension .gz, while keeping the same ownership modes, access and modification times. (The default extension is -gz for VMS, z for MSDOS, OS/2 FAT, Windows NT FAT and Atari.)
			Section 12.2 
		unxz
			A method of uncompressing files compressed using the <command>xz</command> command.
			Section 12.6 
		xz
			Command that can compress or decompress .zx or .lzma files. xz is a general-purpose data compression tool with command line syntax similar to gzip(1) and bzip2(1). The native file format is the .xz format, but also the legacy .lzma format and raw compressed streams with no container format headers are supported.
			Section 12.6 
		xzcat
			Command used to print the contents of files compressed with the <command>xz</command> command to standard output on the terminal without uncompressing the target file.
			Section 12.7 
		zcat
			Command used to display the contents of a compressed file from a compressed archive created by the <command>tar</command> or <command>gzip</command> commands without uncompressing it. Its effect is identical to running the <command>gzip -c</command> command:
			Section 12.3 

	}
}



chapter 13 and 14{

	File Type Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
		^
	}

	Permissions Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
		 ^^^^^^^^^
	}

	User Owner Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
			      ^^^^
	}

	Group Owner Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
				   ^^^^
	}

	Switching Users{
		
		!!! ## By default, if a username is not specified, the su command opens a new shell as the root user. The following two commands are equivalent ways to start a shell as the root user:

		syntax{
			su [OPTIONS] [USERNAME]
		}

		login shell{
			# When switching users, utilizing the login shell option is recommended as the login shell fully configures the new shell with the settings of the new user, ensuring any commands executed run correctly. If this option is omitted, the new shell changes the UID but doesn't fully log in as the user
		
			The login shell option can be specified one of three ways:{

				in terminal{

					su -
					su -l
					su --login

				}

			}
		}

		sudo{
			
			syntax{
				sudo [OPTIONS] COMMAND
			}

		}
	}

	Changing File User Owner{

		## Initially, the owner of a file is the user who creates it. The user owner can only be changed by a user with root privileges using the chown command

		syntax{
			chown [OPTION]... [OWNER] FILE..
		}
	}

	Switching Groups{
		## To create a file or directory that will be owned by a group different from your current primary group, one option is to change your current primary group to another group you belong to by using the newgrp command.

		syntax{
			newgrp [GROUP]
		}

		## Once in the new shell, any file created, in this case, newfile.txt, will belong to the new primary group
	}

	Changing File Group Owner{

		## Another option is for the user owner of the file to change the group owner by using the chgrp command. For example, if you forgot to use the newgrp command to switch to the user’s primary group before creating the file.
	}

	chmod{
		symbol method{
			
			# + = - u = user, g = group, o = other, a = all

			# r = read
			# w = write
			# x = execute

		}

		in terminal {
			touch permissions.txt

			chmod g-r permissions.txt # minus read from group
			chmod g+r permissions.txt # add read to group

			chmod u+w permissions.txt # add write to user

			chmod o=w,g-r,u+x permissions.txt # other = write, group - read, user add execute

			chmod a=- permissions.txt # clear all permissions
		} 
		octal method{
			
			read( r ) = 4
			write( w ) = 2
			execute( x ) = 1
			none = 0
			
		}

		in terminal{
			chmod 765 permissions.txt # adding read, write and execute

			chmod 000 permissions.txt # clear all permissions

			# chmod user,group,other permissions.txt
		}


		more about octal method{
			7 : rwx
			6 : rw-
			5 : r-x
			4 : r--
			3 : -wx
			2 : -w-
			1 : --x
			0 : ---
		}

		setuid{
			# When the setuid permission is set on an executable binary file (a program), the binary file is run as the owner of the file, not as the user who executed it. This permission is set on a handful of system utilities so that they can be run by normal users, but executed with the permissions of root, providing access to system files that the normal user doesn't normally have access to.

			in terminal symbolically{

				add{
					chmod u+s file
				}

				remove{
					chmod u-s file
				}

			}

			in terminal octal{
				
				add{
					chmod 4000 file
				}

				remove{
					chmod 0000 file
				}
			}

			## Permission with the octal method using three-digit codes. When a three-digit code is provided, the chmod command assumes that the first digit before the three-digit code is 0. Only when four digits are specified is a special permission set.
			## If three digits are specified when changing the permissions on a file that already has a special permission set, the first digit will be set to 0, and the special permission will be removed from the file.
		}

		setgid{
			# The setgid permission is similar to setuid, but it makes use of the group owner permissions. There are two forms of setgid permissions: setgid on a file and setgid on a directory. The behavior of setgid depends on whether it is set on a file or directory.
			# The setgid permission on a file works very similarly to the setuid permission, except that instead of executing as the user who owns the file, setgid permission will execute as the group that owns the file. The system allows the user running the command to effectively belong to the group that owns the file, but only in the setgid program.
		
			in terminal symbolically{
				
				add{
					chmod g+s <file|directory>
				}

				remove{
					chmod g-s <file|directory>
				}
			}

			in terminal octal{
				
				add{
					chmod 2000 <file|directory>
				}

				remove{
					chmod 0000 <file|directory>
				}
			}

		}

		Sticky Bit{
			# Setting this permission can be important to prevent users from deleting other user's files.

			in terminal symbolically{
				
				add{
					chmod o+t <directory>
				}
				
				remove{
					chmod o-t <directory>
				}
			}

			in terminal octal{
				
				add{
					chmod 1000 <file|directory>
				}

				remove{
					chmod 0000 <file|directory>
				}
			}
		}

		special Sticky + setgid{
			
			in terminal{
				chmod 3770 <file>

				output{
					drwxrws--T. 2 <user> <group> 4096 Jan 10 09:08 <file>
				}
			}

			## Notice that the special permissions of setgid and sticky bit can be added together, the 2000 permission plus the 1000 permission gives you 3000 for the special permissions. Add this to the basic permissions for the user, group, and others; The owner and group have full access, and others get none.
		
			## The uppercase T in the execute permission position for others indicates there is no execute permission for others. However, since multiple users of the group still have access, the sticky permission is effective for the group.
		}
	}

	key terms for chapter 13{
		
		chgrp
			Command that is used to change the primary group of a file. Essentially it changes what group is the owner of the FILE.
			Section 13.2.4 
		chmod
			Command that is used to change the mode bits of a FILE. The chmod utility can be used to change the files permissions. For example setting the read, write, and execute bits.
			Section 13.4 
		chown
			Command that is used to change the ownership of a FILE. The chown utility can also be used to change the primary group of a FILE as well.
			Section 13.2.2 
		umask
			Command that sets the calling process's file mode creation mask. The umask utility will set the default permissions for FILEs when they are created.
			Section 13.7 


	}

	-------------- chapter 14 begining ----------------------------------------------------------------------------------------------------------------------------------------------

	users{
		sudo adduser **name** # create user

		cat /etc/passwd | grep ^**name** # to loced user
	}

	df -i # Inodes table


	links{
		in terminal{
			touch file.txt file1.txt
		}

		hardlink{
			
			syntax{
				ln TARGET LINK_NAME
				## To create hard links, the ln command is used with two arguments (and without the -s option). The first argument is an existing file name to link to, called a target, and the second argument is the new file name to link to the target.
			}

			in terminal{
				ln file.txt hardlink_to_file.txt # using hardlink to link to file.txt
			}

			filename, incode{
				passwd : 123
				shadow : 175
				group : 144
				gshadow : 897
			}

		}

		softlinks{
			
			syntax{
				ln -s TARGET LINK_NAME
			}

			in terminal{
				ln -s file1.txt symlink_to_file1.txt # -s for softlinks this is a symbolicklink, Softlinks(symbolicklinks) can be used like shortcuts linking a file to another file
			}

		}


		ls -li # see everything with Inodes numbers
	}
}


chapter 15{
	in class{ 
		chapter 15: hardware configuration

			1- Core hardware

			CPU central processing unit

			Ram randon access memory

			Storage like hard drives, CDROMs, and DVDs

			Display and keyboard



			2- generating CPU info

			lscpu //informatino about cpu

			uname -m //cpu architecture

			cat /proc/cpuinfo //displays information about the cpu



			3- Generating Memory info



			cat /proc/meminfo

			free



			4- Generating hard disk info

			df -h

			sudo fdisk -l



			5- generaing PCI and USB info

			lspci

			lsusb



			6- inserting, removing and updating Modules in Linux

			sudo lsmod // list all the modules

			sudo modinfo <Module Name>

			sudo rmmod <path to the module>

			sudo insmod <path of the module>
	}

	me read{

		Central Processing Unit{ 
			## The central processing unit (CPU) is the brain of the computer, where the instructions to perform calculations or manipulate data are processed. There are numerous types of CPUs that are able to work with Linux, but the most common is the 64-bit x86_64 type, and decreasingly, the 32-bit x86 type. Both of these types of CPUs are backward compatible with the CPU used in the first IBM Personal Computer (PC), the Intel 8088 CPU.

			uname{
				Information 		Option 		Example
				Kernel name 		-s 			Linux
				Nodename 			-n 			localhost
				Kernel release 		-r 			4.4.0-72-generic
				Kernel version 		-v 			#93~14.04.1-Ubuntu SMP Fri Mar 31 15:05:15 UTC 2017
				Machine hardware 	-m 			x86_64
				Processor 			-p 			x86_64
				Hardware platform 	-i 			x86_64
				Operating System 	-o 			GNU/Linux
			}
		}

		Random Access Memory{
		
			Consider This

			Unit 			Abbreviation 	Value (Bytes)
			kibibyte 		KiB 			1024
			mebibyte 		MiB 			10242 = 1,048,576
			gibibyte 		GiB 			10243 = 1,073,741,824
			tebibyte 		TiB 			10244 = 1,099,511,627,776
			exbibyte 		EiB 			10246 = 1,152,921,504,606,846,976

			A typical desktop in the year 2019 has 16 GiB of RAM. That is more than 26000 times the amount of RAM in a fully loaded IBM PC in the year 1981!

			in terminal{
				cat /proc/meminfo

				output{
					MemTotal:       132014640 kB
					MemFree:         67439868 kB
					MemAvailable:    99487364 kB
					Buffers:          2116936 kB
					Cached:          27429740 kB
					SwapCached:            40 kB
					Active:          14409408 kB
					Inactive:        23724500 kB
					Active(anon):     8400252 kB
					Inactive(anon):    191680 kB
					Active(file):     6009156 kB
					Inactive(file):  23532820 kB
					Unevictable:            0 kB
					Mlocked:                0 kB
					SwapTotal:      134196220 kB
					SwapFree:       134195752 kB
				}
			}

			in terminal{
				free

				output{
					              total        used        free      shared  buff/cache   available
					Mem:         128920       35120       89205           2        4594       93190
					Swap:        131050         140      130910
				}
			}
		}

		Mass Storage Devices{ 
			# The Small Computer System Interface (SCSI) is one of the oldest and requires a SCSI controller in the system to control one or more disk drives that connect to it.

			# The Integrated Drive Electronics (IDE) or Parallel Advanced Technology Attachment (PATA) type interface includes the controller directly on each drive and was very popular for hard disks through the 1990s. This type is still used for some optical drive devices today.

			# The most common interface used for internal mass storage devices today is the Serial Advanced Technology Attachment (SATA) type. Each SATA drive is connected directly to the system board by a cable. To configure the primary SATA drive, connect it with a cable to the connector of the system board that is designated as the primary port.

			# For external drives, the Universal Serial Bus (USB) interface is the most common, but there are other standards such as FireWire and Thunderbolt.
		}

		Firmware{
			BIOS{
				# Originally, this firmware was known as the Basic Input/Output System (BIOS), System ROM, or ROM BIOS. BIOS is used to provide basic services, called input and output services before an operating system is loaded, so the user may provide input through the keyboard or see output on a monitor even before the bootloader or an operating system is executed.
			}

			UEFI{
				# Recently, computer manufacturers have begun to replace the traditional BIOS with something called the Unified Extensible Firmware Interface (UEFI); however, the functions of UEFI appear so similar to BIOS that many people still refer to the system firmware as BIOS.
			}

			about BIOS and UEFI{
				# Both UEFI-based systems and BIOS-based systems provide a proprietary menu program that allows integrated devices to be enabled or disabled. The firmware that is included varies with each system vendor, so, unfortunately, there is no standard way to start this program or standard menu item for enabling or disabling devices.
			}

			Secure Boot and CSM{
				‌⁠​​⁠​If a system has UEFI firmware, then it may be more challenging to boot the Linux operating system due to a feature called Secure Boot. If Secure Boot is enabled, then the bootloader must be cryptographically signed by a digital key that is recognized by the firmware. If the bootloader is not properly signed, then booting may still be possible by disabling Secure Boot in the firmware settings, in favor of the Compatibility Support Module (CSM).
			}
		}

		Hardware Resources{ 
			IO Ports{
				# Memory addresses that allow for communication with hardware devices

				in terminal{
					cat /proc/ioports

					output{
						0000-0cf7 : PCI Bus 0000:00
							0000-001f : dma1
							0020-0021 : pic1
							0040-0043 : timer0
							0050-0053 : timer1
							0060-0060 : keyboard
							0064-0064 : keyboard
					}
				}
			}

			IO Memory{
				#  A section or location that acts much like the RAM that is presented to the processor via the system bus. These are used to pass and store data as well as for access to devices on the system
				
				in terminal{
					cat /proc/iomem

					output{
						00010000-0009ffff : System RAM
						000a0000-000bffff : PCI Bus 0000:00
						000c0000-000c7fff : Video ROM
						000c8000-000cdfff : Adapter ROM
						000f0000-000fffff : System ROM
						00100000-be777fff : System RAM
							06000000-0680bdb2 : Kernel code
							0680bdb3-06f45abf : Kernel data
					}
				}
			}

			Interrupt Requests (IRQ){
				#  An interrupt is a hardware signal that pauses or stops a running program so that the interrupt handler can switch to running another program, or send and receive data. There are a set of commonly-defined interrupts called IRQ’s that map to common interfaces, such as the system timer, keyboard controller, serial and parallel ports, and floppy controllers.
			}

			Direct Memory Access (DMA){
				# A method by which particular hardware items in the system can directly access RAM, without going through the CPU. This speeds up access, as the CPU would otherwise be fully tasked during such access, making it unavailable for other tasks for the duration.

				in terminal{
					cat /proc/dma

					output{
						4: cascade
					}
				}
			}

			## Note that, with the exception of interrupt requests, these resources cannot be shared between devices. Also, keep in mind that administrators rarely need to view this data on modern Linux systems as the configuration of devices is almost always transparent and automatic.
		}

		Viewing Hardware{
			## Modern computers typically use the Peripheral Component Interconnect Express (PCIe) bus to connect components inside the computer. For example, video, sound, network, and disk controllers are normally found on the PCIe bus.
			
			## A bus is not only used to refer to actual physical connections, but also software components designed to connect programs and certain communications protocols. Components are attached with a type of bus and communicate through it at high rates of speed.
		
			internal and external bus (ISA, SCSI, USB){
				Buses can be alternatively grouped into internal and external bus types. Internal buses are considered to be inside the actual computer, while external or “expansion” buses are used to attach external devices to the computer. Good examples of internal buses are the aforementioned PCIe bus, the older Industry Standard Architecture (ISA) bus, and the very popular Small Computer Systems Interface (SCSI) bus. An example of an external or expansion bus type would be the most universally available Universal Serial Bus (USB) bus.
			}

			ls???{
				# First among these is the lspci command, designed to show the user the PCI buses and devices attached to them.
				# For viewing external devices, the lsusb command will show those that are specifically connected to the Universal Serial Bus (USB).
			}

			usb-devices{
				Another tool for viewing details about USB devices connected to the system is the usb-devices command. This is a script, which when executed will display information about the USB device that can otherwise be found in the /sys or /proc directories, including; the USB device number, vendor, port and more:

				in terminal{
					usb-devices | tail -n 15

					output{
						S:  Manufacturer=Avocent
						S:  Product=USB Composite Device-0
						S:  SerialNumber=20120430
						C:  #Ifs= 2 Cfg#= 1 Atr=c0 MxPwr=2mA
						I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=01 Driver=usbhid
						I:  If#= 1 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=usbhid

						T:  Bus=06 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12  MxCh= 2
						D:  Ver= 1.10 Cls=09(hub  ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
						P:  Vendor=1d6b ProdID=0001 Rev=04.04
						S:  Manufacturer=Linux 4.4.0-72-generic uhci_hcd
						S:  Product=UHCI Host Controller
						S:  SerialNumber=0000:00:1d.1
						C:  #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=0mA
						I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
					}
				}
			}

			### If the user requires more information than the lspci and lsusb commands show normally, simply append a -v option to either command and a great deal more information will be shown; taking the output from one line per item to a stanza-based output where each item is shown with multiple details.

			### Finally, if a user has an issue with a component and is able to see that component mentioned in the lspci -v output, they can get more information about the malfunctioning component by referring to the multiple digit vendor and device code that prefaces the stanza for each device. For example, to get more information about the IDE interface from the machine above, the user can run the lspci command with the -v and -s options followed by the vendor and device code as a parameter. The -s option will allow for a domain to be specified which will display information solely about devices in that domain

			### To isolate the details of a specific USB device, find the vendor and device code in the output of the lsusb command, then use the lsusb command again, this time with the -v and -d options to get the isolated details of a device. The -d option will allow for a vendor or product ID to be specified, which will only display devices with that number.
		}

		Hardware Subsystems{
			tree{
				For example, in the /proc directory, you can use the tree command to show a hierarchical tree of the files and directories that are contained there. However, the listing will be many pages long, so using the less command will be of great benefit in scrolling up and down and looking at the output.

				in terminal{
					tree /proc | less

					output{
						/proc
						|-- 1
						|   |-- attr
						|   |   |-- current
						|   |   |-- exec
						|   |   |-- fscreate
						|   |   |-- keycreate
						|   |   |-- prev
						|   |   `-- sockcreate
						|   |-- autogroup
						|   |-- auxv
						|   |-- cgroup
						|   |-- clear_refs
						|   |-- cmdline
						|   |-- comm
						|   |-- coredump_filter
						|   |-- cpuset
						|   |-- cwd -> [Error\ reading\ symbolic\ link\ information]
						|   |-- environ
						|   |-- exe -> [Error\ reading\ symbolic\ link\ information]
						|   |-- fd [error opening dir]
						|   |-- fdinfo [error opening dir]
						|   |-- gid_map
						:
					}
				}
			}

			lshal{
				To view the list of devices and their attributes that have been stored by hald, execute the lshal command. The lshal command's output will likely contain thousands of lines of text. To see information about specific devices, make use of the grep command, as shown in the following example:

				in terminal{
					lshal | grep cdrom | grep true

					output{ // can be different
						storage.cdrom.dvd = true   (bool)
						storage.cdrom.mrw = true   (bool)
						storage.cdrom.mrw_w = true   (bool)
						storage.cdrom.support_media_changed = true   (bool)
						storage.cdrom.support_multisession = true   (bool)
					}
				}
			}

			D-Bus{
				# Finally, when programs want information about devices, they are able to query hald by using D-Bus.

				# D-Bus is a method of allowing inter-process communications, primarily the communications between components in the Linux Desktop environments, KDE and GNOME. Without D-Bus, desktop environments will communicate between components with many separate processes, each requiring its own one-to-one communication with other components. This produces a confusing communications environment and can contribute to inefficiency and a lack of reliability and instability in the graphics subsystem.

				# D-Bus is a software bus that allows individual and groups of processes to communicate on a single virtual bus or channel, a feature called Interprocess Communication (IPC).
			}
		}

		key terms{
			
			/dev/
				Hardware devices are made available through special files under the /dev directory.
				Section 15.6 
			/proc/
				The process information pseudo-filesystem
				Section 15.6 
			/sys/
				The mount point for sysfs providing a set of virtual files by exporting information about various kernel subsystems, hardware devices and associated device drivers from the kernel's device model to user space.
				Section 15.6 
			lsmod
				Prints the contents of the /proc/modules file
				Section 15.7 
			lspci
				Prints detailed information about all PCI buses and devices in the system
				Section 15.5 
			lsusb
				Prints detailed information about all USB buses and devices in the system
				Section 15.5 
			modprobe
				Used to add a loadable kernel module (LKM) to the Linux kernel or to remove an LKM from the kernel
				Section 15.7 
			swap space
				Used when the amount of physical memory (RAM) is full. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space.
				Section 15.2.2 
		}
	}
}

chapter 16{
	in class{
		Basic Input Output System (BIOS)
				-The first program 
				-runs from ROM
				-OS independent
		Power over self-test (POST)
				-Power-on self-test core hardware check 
		Boot an OS from a Storage device
				-Proceed through the list until it finds a MBR 
		(MBR) Master Boot Record
				-First sector of the drive normally 512MB of storage space
				- Bootloader may reside in the MBR
				-And/or may reside elsewhere
		MBR runs the bootloader
				-Bootloader loads the OS
				-May be automatic or prompt for options
				-LILO, GRUB, GRUB2
				May create an initrd image initial ramdisk
				-“Initial ramdisk”
				-A RAM based file system
		Bootloader loads the kernel
				-/boot/vmlinuz
				-the kernel may be a compressed file
		Gets the hardware running
				-Linux run command
				File system is mounted
				-kernel runs init or systemd
	}

	The boot process takes place in four main stages, some of which are modified by administrators, while for the others, it is sufficient just to be aware of the actions taking place{
		1. Firmware Stage
		2. Bootloader
		3. Kernel Stage
		4. Init Stage
	}

	BIOS{
		# Most PC firmware is referred to as the Basic Input/Output System (BIOS). The BIOS is stored on the motherboard in non-volatile memory such as Read Only Memory (ROM) or flash memory.

		The BIOS has three main jobs to perform as part of the first stage of the boot process{
			
			1. Execute a power-on self test (POST) in order to ensure the hardware of the system is functioning properly. The POST runs some basic functional checks on the CPU, memory, and peripherals so that obvious errors, such as missing memory chips or malfunctioning disk devices are found early in the boot cycle.

			2. Enumerate available hardware such as memory, disks, and USB devices.

			3. Find the proper boot drive from the available storage devices and load the Master Boot Record (MBR) from that device. The Master Boot Record is the first sector (or 512 bytes) of the disk.
		}
	}

	# The most common bootloader used on machines is the Grand Unified Bootloader (GRUB). The latest version of GRUB supports booting Linux from a system using UEFI, interactive editing of the menu during bootup, and much more.

	Consider This{
		Outside of the IBM PC compatible architectures, there are additional bootloaders that are used. For Linux systems to boot on Sparc hardware, there is Sparc Improved bootLOader (SILO), and for PowerPC hardware, there is Yet Another BOOTloader (YABOOT).
	}

	# ‌⁠​​⁠​ It is also possible to boot off the network through the Preboot Execution Environment (PXE). In the PXE system, a compatible motherboard and network card contain enough intelligence to acquire an address from the network and use the Trivial File Transfer Protocol (TFTP) to download a special bootloader from a server.

	init{
		The init stage finishes booting the system. The first process of the operating system (also called init) is started. The init process has three important responsibilities{
			1. Continue the booting process to get services running, login screens displaying, and consoles listening.
			2. Start all other system processes.
			3. Adopt any process that detaches from its parent.
		}
	}

	Kernel Messages{
		The dmesg command can be executed after booting the system to see the messages generated by the kernel during boot time. This is useful when the system doesn't appear to boot correctly; the messages displayed can help an administrator troubleshoot the boot process.
‌⁠​​⁠		 Kernel messages are stored in a ring buffer of limited size; therefore, the messages that are generated at boot time may be overwritten later as the buffer fills up. It is possible that some of the kernel messages generated at boot time may be stored in the /var/log/dmesg file. Each time the system boots, the /var/log/dmesg file is overwritten with the messages that were generated during the boot process.
		It is common to execute the dmesg command upon connecting a new device to the system. This allows the administrator to see how the kernel dealt with the new device and usually to see what path name the new device has been assigned.
	}
}

Chapter 17: Bootloaders{
	in class{
		What is the bootloader:
			- is a small programs that are used to load other programs

			Type of bootloaders:
			- GRUB Grand unified bootloader -->lagacy
			- GRUB2
			- LILO Linux loader old type of bootloader

			- Primary task of the bootloader is to load the kernel

		To install bootloader GRUB:
			sudo grub-mkconfig -o /boot/grub/grub.cfg

		GRUB2
			Dynamically loaded modules
			Non-Ascii charater support
			boot from any partition LVM

			/boot/grub/grub.cfg

			update-grub or grub2-mkconfig

		Install GRUB
			/sbin/grub2-install /dev/sda1
			sudo grub-mkconfig -o /boot/grub/grub.cfg
			update-grub //create boot file in debian distribution
	}

	GRUB Legacy Boot Steps{
		All bootloaders work in stages, as the location for the initial bootloader code is very small, under 512 KB, and GRUB Legacy gets around this by utilizing 2.5 stages to load the entire bootloader and reach the main system’s bootloader.
		GRUB Legacy typically writes the stage 1 bootloader to the Master Boot Record (MBR), and that is just enough code to get the stage 1.5 bootloader, which usually occupies the first 30KiB of the disk that directly follows the MBR. The stage 1.5 loader has just enough code to load up the filesystem drivers needed to load the stage 2 loader from the /boot/grub location.
		The GRUB Legacy bootloading stages will then turn over the rest of the system initialization to the /sbin/init or systemd equivalent for the continuation of the system boot.
	}

	GRUB Legacy Configuration{
		in terminal{
			grub-mkconfig -o /boot/grub/grub.cfg
			# In the example above, the -o option specifies the output location, which is the /boot/grub/grub.cfg file. That file will contain the gathered information formatted accordingly and should be what the system needs to boot the currently installed system properly.
		
			# While the location of grub.conf is the /boot/grub/grub.conf file, on some systems a symbolic link named /etc/grub.conf makes it easier for the administrator to find
			in terminal{
				ls -l /etc/grub.conf
				output{
					lrwxrwxrwx 1 root root 22 Jun 18  2012 /etc/grub.conf -> ../boot/grub/grub.conf
				}
			}

			Keep in mind that only the root user can modify the /boot/grub/grub.conf file. A typical /boot/grub/grub.conf file would look something like the following{
				#global options
				default=0
				fallback=1
				timeout=5
				splashimage=(hd0,0)/grub/splash.xpm.gz
				hiddenmenu
				password notencypted

				#bootable title sections
				title CentOS (2.6.32-358.6.1.el6.i686)
					root (hd0,2)
					kernel /vmlinuz-2.6.32-358.6.1.el6.i686 ro root=/dev/mapper/vg_livecd-lv_root rd_NO_LUKS LANG=en_US.UTF-8 rd_LVM_LV=vg_livecd/lv_swap rd_NO_MD rd_LVM_LV=vg_livecd/lv_root SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
					initrd /initramfs-2.6.32-358.6.1.el6.i686.img
				title CentOS (2.6.32-358.2.1.el6.i686)
					password --md5 $1$D20Ia1$iN6djlheGF0NQoyerYgpp/
					root (hd0,2)
					kernel /vmlinuz-2.6.32-358.2.1.el6.i686 ro root=/dev/mapper/vg_livecd-lv_root rd_NO_LUKS LANG=en_US.UTF-8 rd_LVM_LV=vg_livecd/lv_swap rd_NO_MD rd_LVM_LV=vg_livecd/lv_root SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
					initrd /initramfs-2.6.32-358.2.1.el6.i686.img
				title OtherOS (Windows)
					rootnoverify (hd0,0)
					chainloader +1
			}
		}

		info{
			Directive 			Meaning
			default= 			Specifies the title to attempt to boot by default after the timeout number of seconds has passed.
			fallback= 			Specifies the title to attempt to boot if the default title fails to boot successfully.
			timeout= 			Specifies the number of seconds to wait before automatically attempting to boot the default title.
			splashimage= 		Specify a background graphic that appears behind the text of the menu.
			hiddenmenu 			Prevents GRUB Legacy from displaying all but the default bootable title until the user presses a key. If the user presses a key, then all titles are displayed.
			title 				The title directive starts a new block of directives that form the directives necessary to boot the system. A title block ends when the next title directive appears or when the end of the file is reached.
			root 				Uses the special hard disk syntax to refer to the location of the /boot directory.
			kernel 				This line specifies the kernel image file, followed by all the parameters that are passed to the kernel, such as ro for read-only and root=/path/to/rootfs.
			initrd 				This line should specify an initial ramdisk that matches the version and release of the Linux kernel. This file provides a minimal filesystem during kernel initialization prior to mounting the root filesystem.
			password 			This option can be used as either a global option or a title option. When specified globally, this requires the user to submit the specified password before appending, editing, or using the GRUB Legacy command line. As a title option, this requires the user to submit the password before GRUB will attempt to boot the title.
			rootnoverify 		This directive is used to specify a bootable partition for a non-Linux operating system.
			chainloader 		Used to specify a path to another bootloader or +1 if the bootloader is located in the first sector of the partition specified by the rootnoverify directive.
		}
	}

	Interacting with GRUB Legacy{
		# When a system first starts up with GRUB Legacy installed as the bootloader, it may only display the default title and the timeout time counting down to zero as the hiddenmenu directive may be specified in the /boot/grub/grub.conf file. If the hiddenmenu directive is not specified, then GRUB Legacy will display all the titles and the timeout time counting down to zero. If no interaction occurs before the countdown reaches zero, then GRUB Legacy will attempt to boot the default title.
		# If any key except Enter is pressed, then the time stops counting down, and a title must be selected manually to attempt a boot. The Up ↑ and Down ↓ arrow keys can be used to select one of the available titles. After selecting a title, the user can press Enter to attempt to boot the selection.
		# If the global password directive has been used, then the P key must be pressed, followed by the password to unlock the ability to use GRUB Legacy 's append, edit, and the GRUB command prompt features
	
		Notice the following options available at the bottom of the previous graphic{
			1. If the A key is pressed, then GRUB Legacy will allow additional kernel parameters to be appended. This is commonly used to specify the runlevel number to take the system to, instead of the default runlevel.
			2. If the E key is pressed, then any of the directives that are included within the selected title can be edited; the root, kernel, or initrd values can be changed in order to be able to boot the system in a different manner. The changes that are made at the GRUB Legacy menu are not permanently edited into the /boot/grub/grub.conf file.
			3. If the C key is pressed at the GRUB Legacy menu, then the GRUB command prompt will be provided. At this command prompt, any GRUB Legacy directives can be added, including specifying custom root, kernel, and initrd directives. If entered correctly, followed by the boot directive, then the system will boot correctly.
		}
	}

	key terms{
		grub-install
			Utility to install GRUB on the hard drive.
			Section 17.6 
		grub-mkconfig
			Utility used to generate a configuration file for GRUB.
			Section 17.8 
		grub.cfg
			GRUB configuration file.
			Section 17.8 
		grub.conf
			GRUB configuration file on Red Hat Linux.
			Section 17.6 
		menu.lst
			configuration file for GRUB legacy.
			Section 17.4
	}
}

chapter 18: Runlevels{
	in class{
		0 shuts down the system
		1 Single user mode for maintenance
		2 debian ditros multiuser mode with GUI
		3 Redhat Multiuser mode with text
		4 Undefined
		5 Red hat runlevel 3 with GUI
		6 Reboot the system
	}
	
	The wall Command{
		# There are instances when the notification may not require the imminent shutdown of the system. This is what the wall command is used for. The wall command can be used to display a message or the contents of a file to all users on the system. For example, the following message is being piped to the wall command from the echo command
		
		in terminal{
			echo -e "The server will be offline on Saturday from\n6:00PM to 12:00PM for scheduled maintenance" | wall Broadcast message from sysadmin@localhost (console) (Wed May 29 22:13:59 2019):

			output{
				The server will be offline on Saturday from
				6:00PM to 12:00PM for scheduled maintenance
			}
		}
	}

	Managing System Services{
		# As the administrator of a system, it is possible to control which services will be provided by the various daemons (processes that run in the background of the system). If you want to test services out or have them temporarily enabled or disabled, then you could manually manage them.
		# Typically, administrators will want to automate the management of services, so when the system is taken to a specific runlevel or target state, they will know what services should automatically be available.
		# To manually manage the state of a service, such as a web server, use the appropriate script in the /etc/rc.d/init.d directory to start, stop, or otherwise change the state of the web server. To manage a service with these scripts, run the script with an argument which specifies what the script is supposed to do.
		# For example, on a Red Hat Enterprise Linux distribution, the script to manage the web server has a path name of /etc/rc.d/init.d/httpd. So, to manually start the web server, you would execute the following command as the root user:

		in terminal{
			[root@localhost ~]# /etc/rc.d/init.d/httpd start
			Starting httpd:

			---------------------------------------------------

			[root@localhost ~]# /etc/rc.d/init.d/httpd stop
			Stopping httpd:

			-----------------------------------------------------

			[root@localhost ~]# service httpd start
			[root@localhost ~]# service httpd stop

			-------------------------------------------------------

			[root@localhost ~]# service httpd restart

			-----------------------------------------------------

			[root@localhost ~]# /etc/init.d/httpd
			Usage: httpd {start|stop|restart|conderestart|try-restart|force-reload|reload|status|fullst
			atus|graceful|help|configtest}
		}

		Argument 		Function
		start 			If the service is not running, then attempt to start it.
		stop 			If the service is running, then attempt to stop it.
		restart 		Stop and then start the service over. If a major configuration change is made to a service, it may have to be restarted to make the change effective.
		condrestart 	Restart the service on the condition that it is currently running.
		try-restart 	Same as condrestart.
		reload 			Read and load the configuration for the service. Reloading the configuration file of a service is normally a less disruptive way to make configuration changes to a service effective, but may not be successful for major changes.
		status 			Show whether the service is stopped or the process id (PID) if the service is running. Note: It is also possible to use the service --status-all command to see the status of all daemons.
		fullstatus 		For the Apache web server, displays the URL /server-status.
		graceful 		For the Apache web server, it gracefully restarts the server. If the server is not running, then it is started. Unlike a normal restart, open connections are not aborted.
		help 			Displays the usage of the script.
		configtest 		Checks the configuration files for correctness. For some services, if the configuration file is modified, then this can be used to verify that the changes have no syntax errors.
	}

	Runlevel Directories{
		# The number in the directory name represents the runlevel that it manages; for example, rc0.d is for runlevel 0 and rc1.d is for runlevel 1. To demonstrate, the directories that are used to manage which services will be automatically started or stopped at different runlevels in our VM can be found in the /etc directory. To display these directories, execute the following command:
		
		in terminal{
			sysadmin@localhost:~$ cd /etc
			sysadmin@localhost:/etc$ ls -d rc*
			rc0.d  rc1.d  rc2.d  rc3.d  rc4.d  rc5.d  rc6.d  rcS.d
		}

		# So, what number is supposed to be provided to a specific script for S and K? Look at the script itself for the line that contains chkconfig:

		in terminal{
			[root@localhost ~]# grep chkconfig /etc/init.d/httpd
			# chkconfig: - 85 15
		}

		# The second to last number 85 of the chkconfig line is the S number to place on this script, the last number 15 is the K number.
	}

	The chkconfig Command{
		# To view all the services that are set to start or stop automatically, the administrator can execute the chkconfig --list command and the output would look something like the following (although there would be many more lines of output):

		in terminal{
			[root@localhost ~]# chkconfig --list
			auditd          0:off   1:off   2:on    3:on    4:on    5:on    6:off
			crond           0:off   1:off   2:on    3:on    4:on    5:on    6:off
			httpd           0:off   1:off   2:off   3:off   4:off   5:off   6:off
			iptables        0:off   1:off   2:on    3:on    4:on    5:on    6:off
			netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off
			netfs           0:off   1:off   2:off   3:on    4:on    5:on    6:off
			network         0:off   1:off   2:on    3:on    4:on    5:on    6:off
			quota_nld       0:off   1:off   2:off   3:off   4:off   5:off   6:off
			rdisc           0:off   1:off   2:off   3:off   4:off   5:off   6:off
			restorecond     0:off   1:off   2:off   3:off   4:off   5:off   6:off
			rsyslog         0:off   1:off   2:on    3:on    4:on    5:on    6:off
			saslauthd       0:off   1:off   2:off   3:off   4:off   5:off   6:off
			sendmail        0:off   1:off   2:on    3:on    4:on    5:on    6:off
			sshd            0:off   1:off   2:on    3:on    4:on    5:on    6:off
			udev-post       0:off   1:on    2:on    3:on    4:on    5:on    6:off
		}

		# To view a single service's settings, use the chkconfig --list SCRIPT command where SCRIPT is the name of a script file found in the /etc/rc.d/init.d directory. For example, to view the web server script, execute:

		in terminal{
			[root@localhost ~]# chkconfig --list httpd
			httpd            0:off   1:off   2:off    3:off    4:off    5:off    6:off
		}

		# To enable the service to start for most runlevels, use the chkconfig SERVICE on command, where the SERVICE is the name of a script file found in the /etc/rc.d/init.d directory. Thus, to enable the web server to start at most runlevels, execute the chkconfig httpd on command:

		in terminal{
			[root@localhost ~]# chkconfig httpd on
			[root@localhost ~]# chkconfig --list httpd
			httpd            0:off   1:off   2:on    3:on    4:on    5:on    6:off
		}
	}

	The /etc/init Directory{
		# For Debian and its derivatives (like Ubuntu), know that the runlevels that are used vary slightly from those defined by the Linux Standard Base 4.1. Runlevels 0, 1, and 6 are the same as the standard. However, runlevel 2 is considered the default runlevel; this runlevel is configured for multiple users with the GUI running, much like the standard runlevel five. Runlevels 3, 4, and 5 are initially the same as runlevel 2.
		
		# If an administrator wants to change the runlevels of a service, the configuration file for that service can be modified in the /etc/init directory. For example, in an installation of Ubuntu which includes the Apache web server, this directory normally contains the /etc/init/apache2.conf Upstart configuration file. Within the /etc/init/apache2.conf file should be two lines which define the runlevels to start and stop the server:

		in terminal{

			start on runlevel [2345]
			stop on runlevel [!2345]
			
			--------------------------------

			# In this case, the service would be started up in runlevels 2 through 5 and would be stopped in runlevels that are not 2 through 5 because the ! character indicates "not these". To change the service to only be available in runlevels 2 and 3, change the lines to be like the following:

			start on runlevel [23]
			stop on runlevel [!23]
		}

		# To disable a service without uninstalling it, an override file can be created in the /etc/init directory. This file should have the same name as the service configuration file, but ending in .override instead of .conf. This is the preferred technique over commenting out the "start on" lines.

		# The contents of the .override file should simply be the word manual, which means that the service will ignore any "start on" lines from the configuration file. For example, to override the apache2 configuration file and disable the web server, execute the following command:

		in terminal{
			[sysadmin@localhost ~]$ sudo 'echo manual > /etc/init/apache2.override'
		}
	}

	The systemctl Command{
		# The systemctl command is used in systems that have systemd as a replacement for the traditional init process. This one command can be used to manually control the state of services, enable or disable automatic starting of services, as well as change system targets.
		# The systemctl command looks in the /usr/lib/systemd directory for information about which symbolic link enables a specific service. This directory is where a service’s files are originally placed when it is installed.
		# It is also possible to edit service files in order to modify the service; however, these changes should be made to service files found in the /etc/systemd directory instead.

		# To manually control the state of a service, use the systemctl command to start, stop, or check the status of that service. For example, to start a service like the web server, execute the following:

		in terminal{
			systemctl start httpd.service

			-----------------------------

			# To shut down the service:

			systemctl stop httpd.service

			-----------------------------

			# To check the state of the service:

			systemctl status httpd.service

			### To view the status of all services use -a or --all

			-------------------------------------------------------

			# To configure a service to start automatically, execute the following:

			systemctl enable httpd.service

			---------------------------------------------------------------------------

			# To configure a service not to start automatically, execute the following:

			systemctl disable httpd.service

			----------------------------------------------------------------------------

			# As previously mentioned, it is possible to change to a different runlevel with the systemctl command:

			systemctl isolate DESIRED.TARGET

			---------------------------------------------------------------------------------------------------------

			# The systemctl command can also manage the low or no power states of the system with command lines such as:

			systemctl hibernate
			systemctl suspend
			systemctl poweroff
			systemctl reboot
		}

		# Similar to the chkconfig --list command, all the services that are supposed to be enabled for a specific target within systemd can be viewed by using a systemctl list-dependencies command for that target, such as:
		# The partial output below shows each level of wanted services below a target and the dependencies between each target indented. You see services like atieventsd.service and gdm.service are wanted by the graphical.target.
		# Also, the graphical.target depends on the multi-user.target and the multi-user.target wants the services abrt-ccpp.service and abrt-oops.service.

		in terminal{
			[root@localhost ~]# systemctl list-dependencies graphical.target
			graphical.target
			├─atieventsd.service
			├─gdm.service
			├─jexec.service
			├─systemd-readahead-collect.service
			├─systemd-readahead-replay.service
			├─systemd-update-utmp-runlevel.service
			├─abrt-ccps.service
			├─abrt-oops.service
		}

		## Consider This{
			Because there are three different types of boot systems, traditional init, Upstart and systemd, the logical question is, "Which one does my system use?" The easy answer to this question is to check for the existence of two directories: the /etc/init and the /etc/systemd directory.
			If your system has a /etc/init directory, then your system is using Upstart. If your system has a /etc/systemd directory, then your system is using systemd. Otherwise, your system is using traditional init.
		}
	}

	Boot Target{
		# Many modern systems use systemd rather than init for setting boot targets. The following table shows the runlevel equivalents for boot targets.

		Runlevel 		Purpose 																		systemd Target
		0 				Halt or shut off the system 													poweroff.target
		1 				Single-user mode for administrative tasks 										rescue.target
		2 				Multi-user mode without configured network interfaces or network services 		multi-user.target
		3 				Normal startup of the system 													multi-user.target
		4 				User-definable 																	multi-user.target
		5 				Start the system normally with a graphical display manager 						graphical.target
		6 				Restart the system 																reboot.target
	}

	acpid{
		# Linux systems use the Advanced Configuration and Power Interface (ACPI) event daemon acpid to notify user-space programs of ACPI events. The ACPI allows the kernel to configure hardware components and manage the system’s power settings, such as battery status monitoring, temperature, and more.
		# One example of using acpid for power management would be having the system shut down after the user presses the power button. On modern systems, acpid is normally started as a background process during bootup and opens an event file in the /proc/acpi directory. For example, the wakeup file in the /proc/acpi directory below displays the following information:

		in terminal{
			sysadmin@localhost:~$ su -
			Password:
			root@localhost:~# ls -l /proc/acpi
			total 0
			-rw-r--r-- 1 root root 0 May 28 21:09 wakeup
			root@localhost:~# cat /proc/acpi/wakeup
			Device  S-state   Status   Sysfs node
			PCI0      S5    *disabled  no-bus:pci0000:00
			root@localhost:~#
		}

		## When the kernel sends out an ACPI event, acpid will determine the next steps based on rules defined in configuration files in the /etc/acpi directory. Administrators can create rules scripts in the /etc/acpi directory to control the actions taken by the system.

		# The acpi command is used to display information about system hardware ACPI settings, it’s not installed on our VM, but the above example shows a basic acpi script in the /proc/acpi directory that controls waking the machine up after being suspended. There are many options available to the acpi command to display various information for power management. The table below summarizes some of the options available to the acpi command:

		Option 				Purpose

		-b | --battery		Displays battery information

		-a | --ac-adapter	Displays ac adapter information

		-t | --thermal 		Displays thermal information

		-c | --cooling 		Displays cooling device information

		-s | --show-empty 	Displays non-operational devices

		-f | --fahrenheit	Uses Fahrenheit as the temperature unit instead of the default, Celsius

		-i | --details		Displays additional details if they are available; battery capacity and temperature trip points
	}

	key terms{
		
		/etc/init.d/
			Contains scripts used by the System V init tools (SysVinit)
			Section 18.6 
		/etc/inittab
			Configuration file read by init when it starts up to determine what process to start for various run levels.
			| Section 18.2 
		/etc/systemd/
			The location of various unit files that control services controlled by systemd.
			Section 18.11 
		/usr/lib/systemd/
			The location of services provided by installed packages.
			Section 18.11 
		init
			The parent of all processes on the system, it is executed by the kernel and is responsible for starting all other processes.
			| Section 18.4 
		shutdown
			Arranges for the system to be brought down in a safe way. All logged-in users are notified that the system is going down and, within the last five minutes of TIME, new logins are prevented.
			Section 18.4 
		systemctl
			The interface to systemd, the init system used by many Linux distributions. It combines the functionality of both service and chkconfig into a single tool that you can use for instance to enable/disable services permanently or only for the current session.
			Section 18.11 
		systemd
			A full replacement for init with parallel starting of services and other features, used by many distributions.
			| Section 18.1 
		telinit
			Signal init to change the system's runlevel. telinit is actually just a link to init, the ancestor of all processes.
			Section 18.4 
		wall
			Displays a message, or the contents of a file, or otherwise its standard input, on the terminals of all currently logged in users.
			Section 18.5 
	}
}


chapter 19 and 20
	in class{
		Display disks and partitions:
			df -h
			ls /dev/sd*
			ls -i //lists all files and directories with Inode number.



		Creating partitions from command line:
			fdisk:
			sudo fdisk -l /dev/sda //lists existing partitions on a device
			sudo fdisk <partition_name> //an interactive tool that doesn't make change until you "save"



		sudo fdisk /dev/sda
			-p print partition information
			-n create new partition
			-e extended
			-p primary
			-t //change partition type
			-L //display a list of partitions types
			-d //delete a partition
			-q //quit without saving
			-w //to save changes and quit



		sfdisk Scriptable fdisk-like program for automate partitioning
			also used to backup and restore current partition table.
			sfdisk
			sudo sfdisk -s //list disk and sizes
			sudo sfdisk -d /dev/sda1 > sdb1.backup //backup current table before making changes



		creating filesystems
			mkfs -t vfat /dev/sda1 //create a file system



		creating a swap space:
			mkswap /dev/sda1 //initialize a swap partition
			mkswap -L myswap /dev/sda1
			swapon /dev/sda2 //enable swap space
	}