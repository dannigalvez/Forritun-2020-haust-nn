"""

MEANING OF THINGS

	!!! = important

	# = command

	## = interesting

	### = options

	in terminal = in linux terminal

	{} = contents of a specific thing

	syntax = syntax

"""

### -r = is most often recursiv


chapter 11{
	ps
	{ 
		ps[OPTION]...   # The ps command can be used to list processes
				# The ps command supports three styles of options{
					Traditonal UNIX style short options that use a single hyphens[-] in front of a character
					GNU style long options that use two hyphens[-] in front of a word
					BSD style options that use no hyphens[-] and single character options
				}
				# The ps command will display the processes that are running in the current terminal by default

			#ps Columns info{
				PID : The process identifier, witch is unique to the process. This info is useful to control the process by its ID number
				TTY : The name of the terminal ir pseudo-terminal where the process us running. This ifno is useful to distinguish between differebt processes that have the same name
				TIME : The total amount of processor time used by the process. Typically, this info int't used by regular users.
				CMD : The command that started the process.
			}

			# ps x [BSD option] state {
				D : Uninterruptible Sleep
				R : Running
				S : Interruptible Sleep
				T : Stopped
				Z : Zombie
			}

			# ps aux [BSD option] {
				a : Allows the ps command to show all processes
				u : Show processes by all users and ignore restrictions to only list the user's processes
				x : List all processes and remove the restriction to only display
			}# it shows everything

			in terminal{
				ps aux | grep -i sshd # To find all processes that match the sshd string
			}
	}

	pgrep
	{
		in terminal {
			pgrep -i sshd # If you wanted to find all instances of the sshd

			pgrep -li sshd # The output shows the process IDs (PID) of the processes running that match the sshd string. Additionally, the -l option can be used with the pgrep command to list the process name along with the PID

			# It is also possible to search for processes owned by a specific user by using the -u option

			pgrep -u sysadmin -l # In the example above, the -u and -l options displayed the bash process which has the PID 56 and is owned by the sysadmin user.
		}

	}

	watch
	{
		// watch [OPTION]... COMMAND \\
		# The watch command can be use with date for a good test
		# The watch command can also be used with the ps command to monitor running processes in the shell
		in terminal {
			watch ps aux
		}
	}

	## To write a couple of command in one line use the semicolon [ ; ]


	Background Processes
	{
		COMMAND & 
		
		in terminal{
			sleep 3 & # this runs in the Background
		}
	}

	kill
	{
		syntax of kill command{
			kill [OPTION]... <pid>
		}

		### specifying signals for kill command {
			-<signal>
			-s <signal>
			--signal <signal>

			example for interrupt signal{
				-2
				-INT
				-SIGINT
			}
		}


		in terminal{
			kill -l # To see a list of all of the signals available for your system
 		}
		

		common signals{
			number : full name : short name : purpose
			1      : SIGHUB    :  HUP       : Hang up, usually ends a process
			2      : SIGINT    :  INT       : Interrupt, usually ends a process
			3      : SIGQUIT   :  QUIT      : Quit, usually ends a process
			9      : SIGKILL   :  KILL      : Kill, forcefully ends a process
			15     : SIGTERM   :  TERM      : Terminate, usually ends a process
			18     : SIGCONT   :  CONT      : Continue, resumes a stopped process
			19     : SIGSTOP   :  STOP      : Stop, forcefully stops a process
			20     : SIGTSTP   :  TSTP      : Terminal Stop, usually stops a process
		}
	}
	
	pkill{
		syntax{
			pkill [OPTION]... PATTERN
		}
		
		# the pkill command allows users to specify a pattern that matches a process name and then sends signals to that process
	}
	
	killall{
		syntax{
			killall [OPTION]... NAME
		}

		in terminal{
			killall sleep
		}

		# The killall command can also be used to terminate one or more processes by name and other criteria such as the user owner of the process and system processes.
	}

	# top is like the task manager

	key terms{ 
		&
			When used with a process will immediately background the process or task in a terminal. This will allow the terminal to be freed up for additional tasks.
			Section 11.2.6 

		bg
			A job control command that resumes the execution of a suspended process without bringing it to the foreground.
			Section 11.2.7 

		fg
			A job control command that resumes execution of a suspended process by bringing it to the foreground.
			Section 11.2.7 

		free
			Command used to display the amount of free and used memory in the system. This utility will display both the physical and swap memore on the system as well as the buffers used by the kernel.
			Section 11.2.3 | Section 11.3 

		jobs
			Command that lists all active jobs in the current terminal or shell.
			Section 11.2.6 

		kill
			Command used to terminate a process. There are specific signals that can terminate a process in different ways. If no signal is provided the TERM signal will be sent to the process.
			Section 11.2.8 

		killall
			Command similar to kill, but killall will allow a user to terminate a process by name as opposed to ID.
			Section 11.2.8 

		nice
			Command used to change the priority of a process. The higher the nice value the lower the priority of a process. Nice values range from -20 to 20.
			Section 11.2.10 

		nohup
			Command used to run a command immune to hangups, with output to a non-tty. If standard input is a terminal, it can be redirected from /dev/null. If standard output is the terminal, append the ouptput to nohup.out. This should be located in the user's home directory.
			Section 11.2.9 

		pgrep
			Command that parses through the running processes and looks for the specified names or other criteria of processes.
			Section 11.2.2 

		pkill
			Sends a specified signal (SIGTERM by default) to each process instead of listing them on stdout.
			Section 11.2.8 

		ps
			Command used to report a snapshot of the current processes. Different options are available with ps to report more specific information.
			Section 11.2.1 

		renice
			Command used to change the priority of a process while that process is running. The higher the value the lower the priority.
			Section 11.2.10 

		screen
			A full-screen software program that can be used to multiplex a physical console between several processes (typically interactive shells). It offers a user to open several separate terminal instances inside a one single terminal window manager. The screen application is very useful, if you are dealing with multiple programs from a command line interface and for separating programs from the terminal shell. It also allows you to share your sessions with others users and detach/attach terminal sessions.
			Section 11.4.1 

		tmux

			Section 11.4.2 

		top
			Command similar to ps, however top will display the curent real-time view of all running tasks and processes.
			Section 11.2.11 

		uptime
			Command that will display how long a system has been running. uptime gives a one line display showing the current time, how long ths system has been running, how many users are logged in, and the system load averages for the pas 1, 5 and 15 minutes.
			Section 11.3 
			
		watch

			Section 11.2.3 
	}

}


chapter 12{
	# Archiving: Combines multiple files into one, which eliminates the overhead in individual files and makes it easier to transmit.

	#Compression: Makes the files smaller by removing redundant information
	
	gzip and gunzip{
		# The gzip command is used to create a compressed file. Likewise, the gunzip command is used to view the contents of a compressed file, as well as extract those contents.
		
		syntax{
			gzip [OPTION]... [FILE]...
			gunzip [OPTION]... [FILE]...
		}

		# gzip2 compresses
		# gunzip2 uncompresses

		!!! The gzip command should be used with caution since its default behavior is to replace the original file specified with a compressed version.
	}

	zcat{
		# The zcat command is used to display the contents of a compressed file without actually uncompressing it

		syntax{
			zcat [OPTION]... [FILE]...
		}
	}

	bzip2 and bunzip2{
		#The bzip2 and bunzip2 commands work in a nearly identical fashion to the gzip and gunzip commands. However, while the gzip command uses the Lempel-Ziv data compression algorithm, the bzip utilities use a different compression algorithm called Burrows-Wheeler block sorting, that can compress files smaller than gzip at the expense of more CPU time
	
		syntax{
			bzip2 [OPTION]... [FILE]...
			bunzip2 [OPTION]... [FILE]...
		}

		# bzip2 compresses
		# bunzip2 uncompresses

		!!! The bzip2 command should be used with caution since its default behavior is to replace the original file specified with a compressed version.

		!!! ### -r recursion dose not work with bzip2 and bunzip2

		### The -v option gives a verbose output so you can see how the file was processed
	}

	bzcat{
		# The bzcat command prints the content of specified files compressed with the bzip2 command to the standard output.

		syntax{
			bzcat [OPTION]... [FILE]...
		}
	}

	xz and unxz{
		# Another archival tool similar to gzip and bzip2 is the xz command.
		### To compress a group of files individually, use the xz command with the -z option. Compression is the default operation mode, and therefore if the xz command is run with no options, the -z option is implied.

		syntax{
			xz [OPTION]... [FILE]...
		}

		### The -d option can be used with the xz command to uncompress the files just as easily

		# Another method of uncompressing files compressed using the xz command is to use the unxz command. Using unxz to uncompress a file is very similar to using gunzip because it uses similar syntax.
	
		!!! There are a huge number of options for the xz command, some relating to the compression ratio. Keep in mind when using xz that the more aggressive the compression, the harder the processor will have to work.
	}

	xzcat{
		# The xzcat command is used to print the contents of files compressed with the xz command to standard output on the terminal without uncompressing the target file.

		syntax{
			xzcat [FILE]...
		}
	}

	tar{
		## The tar command is typically used to make archives within Linux. These tar archive files, sometimes called tarballs, were originally used to backup data onto magnetic tape. Tar is derived from the words "tape archive".

		# While the primary purpose of the tar command is to merge multiple files into a single file, it is capable of many different operations, and there are numerous options

			tar functionalitys{
				
				### Create = -c # Make a new archive out of a series of files.

				### Extract = -x # Pull one or more files out of an archive.

				### List = -t # Show the contents of the archive without extracting.

			}

		Create Mode{

			syntax{
				tar -c [-f ARCHIVE] [OPTIONS] [FILE...]
			}

			### -c = create an archive.
			
			### -f ARCHIVE = Use the ARCHIVE file. The argument ARCHIVE will be the name of the resulting archive file.

			## All the remaining arguments, [FILE…], are considered as input file names either as a list of files, as a wildcard, or both.

			in terminal{
				tar -cf mydocuments.tar ~/Documents
			}
			
			### -v = Verbosely list the files processed.
			
			### -z = Compress (or decompress) the archive using the gzip command.

			### -j = Filter the archive through the bzip2 command

			### -J = Filter the archive through the xz command.

			## File extensions are not relevant to Linux; however, it is customary to add .tar.gz to the name of the compressed archive. 

			in terminal{
				tar -cvzf mydocuments.tar.gz ~/Documents
			}

		}

		List Mode{
			
			syntax{
				tar -t [-f ARCHIVE] [OPTIONS]
			}

			### -t = List the files in the archive. (table of contents)

			### -f ARCHIVE = Operate on the given archive. 

			in terminal{
				tar -tf mydocuments.tar.gz
			}

			## note that the -f option is used last so that the file name can be specified as an argument to this option

			in terminal{
				# you can add the verbose (-v) to get a more detailed output

				tar -tvf mydocuments.tar.gz
			}

		}

		Extract Mode{

			syntax{
				tar -x [-f ARCHIVE] [OPTIONS]
			}

			### -x = Extract files from an archive.

			### -f ARCHIVE = Operate on the given archive.

		}
	}

	zip and unzip{

		syntax{
			zip [OPTIONS]... [FILE]...
		}

		### One especially useful option for the zip command is the -r option, which allows the zip command to recursively compress

		# The unzip command is used to extract the files from the zip archive file. Use the unzip command without options to extract a zip archive

		### To view the contents of a zip file without unpacking it, use the unzip command with the list -l option:
	}

	cpio{
		## In copy-out mode, the cpio command will copy files from a directory into an archive.

		## In copy-out mode, the cpio command will copy files from a directory into an archive.

		## There is a third mode called the copy-pass mode. In this mode, the cpio command copies files from one directory to another, which combines the copy-out and copy-in modes without creating an archive file.
	
		Copy-Out Mode{
			### The -o option puts the cpio command into copy-out mode

			### Using the verbose -v option will cause the cpio command to list the files that it processes

			in terminal {
				ls | cpio -ov > archive.cpio
			}

			find command{

				in terminal{
					find . -depth -print | cpio -vo > /tmp/ar.cpio
				}

			}
		}

		Copy-In Mode{

			### To extract the files that are in a cpio archive, use the -i option with the cpio command to specify copy-in mode

			### By default, cpio will not overwrite existing files unless the -u option is used.

			!!! ### The cpio command will not create directories unless the -d option is used.

			in terminal{

				cpio -idv /tmp/test < /tmp/ar.cpio

				find ~ | cpio -pd /tmp/destination

			}

			## To specify the pass-through mode of the cpio command, specify the -p option. Again, if any directories are included, the -d option needs to be specified

			## To prevent problems with files that have white space characters (like the spacebar character) embedded in them, specify the -print0 option to the find command

			## For the cpio command to process the list of null separated files, add the --null option. This results in a more robust version of the previous pass-through command

			in terminal{
				find . -print0 | cpio --null -pvd /tmp/destination
			}

		}
	}

	dd{
		# The dd command is a utility for copying files or entire partitions at the bit level

		dd features{
			
			It can be used to clone or delete (wipe) entire disks or partitions.
			
			It can be used to copy raw data to removable devices, such as USB drives and CDROMs.
			
			It can backup and restore the MBR (Master Boot Record), a critical software component that is used to boot the system.
			
			It can be used to create a file of a specific size that is filled with binary zeros, which can then be used as a swap file (virtual memory).

		}

		dd commonly used special arguments{
			if=FILE : The input file to be read.
			of=FILE : The output file to be written.
			bs=SIZE : The block size to be used. By default, the value is considered to be in bytes. Use the following suffixes to specify other units: K, M, G, and T for kilobytes, megabytes, gigabytes, and terabytes respectively.
			count=NUMBERS : The number of blocks to read from the input file.
		}

		in terminal{
			# In the following example, a file named /tmp/swapex is created with 500 "one-megabyte" size blocks of zeros:

			dd if=/dev/zero of=/tmp/swapex bs=1M count=500
		}

	}

	key terms{
		
		bunzip2
			Command that uncompresses files compressed using the <command>bzip2</command> command and removes the .bz2 extension.
			Section 12.4 
		bzcat
			Command prints the content of specified files compressed with the <command>bzip2</command> command to the standard output.
			Section 12.5 
		gunzip
			Command that decompress files created by gzip, zip, compress, compress -H or pack.
			Section 12.2 
		gzip
			Command used to comperess or expand files. Gzip reduces the size of the named files using Lempel-Ziv coding (LZ77). Whenever possible, each file is replaced by one with the extension .gz, while keeping the same ownership modes, access and modification times. (The default extension is -gz for VMS, z for MSDOS, OS/2 FAT, Windows NT FAT and Atari.)
			Section 12.2 
		unxz
			A method of uncompressing files compressed using the <command>xz</command> command.
			Section 12.6 
		xz
			Command that can compress or decompress .zx or .lzma files. xz is a general-purpose data compression tool with command line syntax similar to gzip(1) and bzip2(1). The native file format is the .xz format, but also the legacy .lzma format and raw compressed streams with no container format headers are supported.
			Section 12.6 
		xzcat
			Command used to print the contents of files compressed with the <command>xz</command> command to standard output on the terminal without uncompressing the target file.
			Section 12.7 
		zcat
			Command used to display the contents of a compressed file from a compressed archive created by the <command>tar</command> or <command>gzip</command> commands without uncompressing it. Its effect is identical to running the <command>gzip -c</command> command:
			Section 12.3 

	}
}



chapter 13 and 14{

	File Type Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
		^
	}

	Permissions Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
		 ^^^^^^^^^
	}

	User Owner Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
					  ^^^^
	}

	Group Owner Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
						   ^^^^
	}

	Switching Users{
		
		!!! ## By default, if a username is not specified, the su command opens a new shell as the root user. The following two commands are equivalent ways to start a shell as the root user:

		syntax{
			su [OPTIONS] [USERNAME]
		}

		login shell{
			# When switching users, utilizing the login shell option is recommended as the login shell fully configures the new shell with the settings of the new user, ensuring any commands executed run correctly. If this option is omitted, the new shell changes the UID but doesn't fully log in as the user
		
			The login shell option can be specified one of three ways:{

				in terminal{

					su -
					su -l
					su --login

				}

			}
		}

		sudo{
			
			syntax{
				sudo [OPTIONS] COMMAND
			}

		}
	}

	Changing File User Owner{

		## Initially, the owner of a file is the user who creates it. The user owner can only be changed by a user with root privileges using the chown command

		syntax{
			chown [OPTION]... [OWNER] FILE..
		}
	}

	Switching Groups{
		## To create a file or directory that will be owned by a group different from your current primary group, one option is to change your current primary group to another group you belong to by using the newgrp command.

		syntax{
			newgrp [GROUP]
		}

		## Once in the new shell, any file created, in this case, newfile.txt, will belong to the new primary group
	}

	Changing File Group Owner{

		## Another option is for the user owner of the file to change the group owner by using the chgrp command. For example, if you forgot to use the newgrp command to switch to the user’s primary group before creating the file.
	}

	chmod{
		symbol method{
			
			# + = - u = user, g = group, o = other, a = all

			# r = read
			# w = write
			# x = execute

		}

		in terminal {
			touch permissions.txt

			chmod g-r permissions.txt # minus read from group
			chmod g+r permissions.txt # add read to group

			chmod u+w permissions.txt # add write to user

			chmod o=w,g-r,u+x permissions.txt # other = write, group - read, user add execute

			chmod a=- permissions.txt # clear all permissions
		} 
		octal method{
			
			read( r ) = 4
			write( w ) = 2
			execute( x ) = 1
			none = 0
			
		}

		in terminal{
			chmod 765 permissions.txt # adding read, write and execute

			chmod 000 permissions.txt # clear all permissions

			# chmod user,group,other permissions.txt
		}


		more about octal method{
			7 : rwx
			6 : rw-
			5 : r-x
			4 : r--
			3 : -wx
			2 : -w-
			1 : --x
			0 : ---
		}

		setuid{
			# When the setuid permission is set on an executable binary file (a program), the binary file is run as the owner of the file, not as the user who executed it. This permission is set on a handful of system utilities so that they can be run by normal users, but executed with the permissions of root, providing access to system files that the normal user doesn't normally have access to.

			in terminal symbolically{

				add{
					chmod u+s file
				}

				remove{
					chmod u-s file
				}

			}

			in terminal octal{
				
				add{
					chmod 4000 file
				}

				remove{
					chmod 0000 file
				}
			}

			## Permission with the octal method using three-digit codes. When a three-digit code is provided, the chmod command assumes that the first digit before the three-digit code is 0. Only when four digits are specified is a special permission set.
			## If three digits are specified when changing the permissions on a file that already has a special permission set, the first digit will be set to 0, and the special permission will be removed from the file.
		}

		setgid{
			# The setgid permission is similar to setuid, but it makes use of the group owner permissions. There are two forms of setgid permissions: setgid on a file and setgid on a directory. The behavior of setgid depends on whether it is set on a file or directory.
			# The setgid permission on a file works very similarly to the setuid permission, except that instead of executing as the user who owns the file, setgid permission will execute as the group that owns the file. The system allows the user running the command to effectively belong to the group that owns the file, but only in the setgid program.
		
			in terminal symbolically{
				
				add{
					chmod g+s <file|directory>
				}

				remove{
					chmod g-s <file|directory>
				}
			}

			in terminal octal{
				
				add{
					chmod 2000 <file|directory>
				}

				remove{
					chmod 0000 <file|directory>
				}
			}

		}

		Sticky Bit{
			# Setting this permission can be important to prevent users from deleting other user's files.

			in terminal symbolically{
				
				add{
					chmod o+t <directory>
				}
				
				remove{
					chmod o-t <directory>
				}
			}

			in terminal octal{
				
				add{
					chmod 1000 <file|directory>
				}

				remove{
					chmod 0000 <file|directory>
				}
			}
		}

		special Sticky + setgid{
			
			in terminal{
				chmod 3770 <file>

				output{
					drwxrws--T. 2 <user> <group> 4096 Jan 10 09:08 <file>
				}
			}

			## Notice that the special permissions of setgid and sticky bit can be added together, the 2000 permission plus the 1000 permission gives you 3000 for the special permissions. Add this to the basic permissions for the user, group, and others; The owner and group have full access, and others get none.
		
			## The uppercase T in the execute permission position for others indicates there is no execute permission for others. However, since multiple users of the group still have access, the sticky permission is effective for the group.
		}
	}

	key terms for chapter 13{
		
		chgrp
			Command that is used to change the primary group of a file. Essentially it changes what group is the owner of the FILE.
			Section 13.2.4 
		chmod
			Command that is used to change the mode bits of a FILE. The chmod utility can be used to change the files permissions. For example setting the read, write, and execute bits.
			Section 13.4 
		chown
			Command that is used to change the ownership of a FILE. The chown utility can also be used to change the primary group of a FILE as well.
			Section 13.2.2 
		umask
			Command that sets the calling process's file mode creation mask. The umask utility will set the default permissions for FILEs when they are created.
			Section 13.7 


	}

	-------------- chapter 14 begining ----------------------------------------------------------------------------------------------------------------------------------------------

	users{
		sudo adduser **name** # create user

		cat /etc/passwd | grep ^**name** # to loced user
	}

	df -i # Inodes table


	links{
		touch file.txt file1.txt


		ln file.txt hardlink_to_file.txt # using hardlink to link to file.txt

		ln -s file1.txt symlink_to_file1.txt # -s for softlinks this is a symbolicklink

		ls -li # see everything with Inodes numbers
	}
}