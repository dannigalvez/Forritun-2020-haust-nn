"""

MEANING OF THINGS

	!!! = important

	# = command

	## = interesting

	### = options

	in terminal = in linux terminal

	{} = contents of a specific thing

	syntax = syntax

"""

### -r = is most often recursiv


chapter 1{
	key terms{
		
		bash
			Bourne Again SHell - an sh-compatible command language interpreter that executes commands read from the standard input or from a file.
			Section 1.3.1 
		ls
			Command that will list information about files. The current directory is listed by default.
			Section 1.3.1 

	}
}

chapter 2{
	uname{

		Short Option 			Long Option 			Prints
		-a			 	--all 				All information
		-s 				--kernel-name  			Kernel name
		-n 				--node-name 			Network node name
		-r 				--kernel-release 		Kernel release
		-v 				--kernel-version 		Kernel version
		-m 				--machine 			Machine hardware name
		-p 				--processor 			Processor type or unknown
		-i 				--hardware-platform 		Hardware platform or unknown
		-o 				--operating-system 		Operating system
						--help 				Help information
						--version 			Version information
	}

	man{
		Command 			Function
		Return (or Enter) 		Go down one line
		Space 				Go down one page
		/term 				Search for term
		n 				Find next search item
		1G 				Go to the beginning of the page
		G 				Go to the end of the page
		h 				Display help
		q 				Quit man page
	}

	key terms{
		
		Quoting
			Enclosing special characters in quotes will prevent the shell from interpreting special characters. Double quotes will prevent the shell from interpreting some of these special characters; single quotes prevent the shell from interpreting any special characters.
			Section 2.3.1.1 
		echo
			Echo the STRING(s) to standard output. Useful with scripts.
			Section 2.3.1.1 
		man
			An interface to the on-line reference manuals.
			Section 2.9 | Section 2.9.1 | Section 2.9.2 | Section 2.9.3 | Section 2.9.4 | Section 2.9.5 | Section 2.9.6 | Section 2.9.6.1 | Section 2.9.6.2 | Section 2.9.6.3 | Section 2.9.6.4 
		pwd
			Print the name of the current working directory.
			Section 2.6 
		uname
			Print certain system information such as kernel name, network node hostname, kernel release, kernel version, machine hardware name, processor type, hardware platform, and operating system, depending on options provided.
			Section 2.5 

	}
}

chapter 3{
	key terms{
		
		.bash_history
			File used to store the current history list when the shell is closed.
			Section 3.4 
		env
			Print a list of the current Environment variables or change to an alternate environment.
			Section 3.2.1 
		export
			Makes an assigned variable available to sub-processes.
			Section 3.2.1 
		history
			Print a list of previously executed commands or "re-execute" previously executed commands.
			Section 3.4 
		set
			Display all variables (local and environment).
			Section 3.2.2 
		unset
			Remove one or more variables.
			Section 3.2.3 

	}
}

chapter 4{
	key terms{
		
		file globbing
			The glob function searches for all the pathnames matching pattern according to the rules used by the shell. ( * , ? , [] , )
			Section 4.1 | Section 4.2 | Section 4.3 | Section 4.4 

	}
}

chapter 5{
	key terms{

		cp
			Command used to copy files and directories. cp will copy a SOURCE to a DEST, or multiple SOURCES to a DIRECTORY.
			Section 5.5 
		file
			Command used to determine the type of file. file tests each argument in an attempt to classify it. There are three sets of tests, preformed in this order: filesystem test, magic tests, and language tests.
			Section 5.3 
		ls
			Command that will list information about files. The current directory is listed by default.
			| Section 5.2 
		mkdir
			Command used to create directories, if they do not already exist.
			Section 5.8 
		rm
			Command used to remove files or directories. By default the rm command will not remove directories.
			Section 5.7 
		rmdir
			Command that is used to remove empty directories in the filesystem.
			Section 5.9 
		touch
			Command used to change the file timestamps. touch will allow a user to update the access and modification times of each FILE to the current time.
			Section 5.4 

	}
}

chapter 6{
	key terms{
		
		/etc/updatedb.conf
			A configuration file for the updatedb utility. In some implementations, updatedb.conf is a shell script that allows more flexibility in defining variables
			Section 6.3.1 
		find
			Command used to search for files in a directory hierarchy. find searches the directory tree rooted at each given file name by evaluating the given the expression from left to right.
			Section 6.3.2 
		locate
			Command used to search for files by name. locate reads one or more databases prepared by the updatedb utility and writes file names matching at least one of the PATTERNs to standard output.
			Section 6.3.1 
		type
			Command that indicates how a name would be interpreted if used as a command. When using the type utility, the path to the command will be displayed.
			Section 6.3.5 
		updatedb
			The updatedb utility creates or updates a database to be used by the locate utility.
			Section 6.3.1 
		whereis
			Command that is used to locate source/binary and manuals sections for specified rules. This will locate binary, source, and manual pages for a command.
			Section 6.3.3 
		which
			Command that returns the pathnames of the files, or links, which would be executed in the current environment. It does this by searching the PATH for executables matching the names of the arguments.
			Section 6.3.4 

	}
}

chapter 7{
	key terms{
		
		cat
			Displays the contents of one or more files (concatenate) to standard output.
			Section 7.2 
		cut
			Command used to extract fields of information from a text file.
			Section 7.9 
		head
			Prints the first ten lines of a file by default. The number of lines can be set to any desired value.
			Section 7.5 
		less
			Pager command used to view file contents one page of data at a time.
			Section 7.2 
		nl
			Prepend a number to the lines of a file incrementing each line by 1 by default.
			Section 7.4 
		od
			Performs an octal dump of data by default. Often used to display the contents of files with non-printable characters.
			Section 7.12 
		paste
			Merge the lines of one or more files, line by line, separating the output by tabs by default.
			Section 7.7 
		sed
			A non-interactive editor that can be used to modify text.
			Section 7.14 
		sort
			Command used to display a file sorted on a specific field of data.
			Section 7.9 
		split
			Command used to take one file and break it into multiple parts. By default it breaks the file up into 1000 line sections.
			Section 7.3 
		tail
			Prints the last ten lines of a file by default. The number of lines can be set to any desired value.
			Section 7.6 
		tr
			Command used to translate one set of characters to another.
			Section 7.13 
		uniq
			Command to remove duplicate lines that are currently consecutive.
			Section 7.11 
		wc
			Print newline, word, and byte counts for each FILE, and a total line if more than one FILE is specified.
			Section 7.15 

	}
}

chapter 8{
	key terms{
		
		egrep
			Command that performs the same function as grep -E. This command has been deprecated, but is around for historical applications.
			Section 8.3 | Section 8.7 
		fgrep
			Command that performs the same function grep -F. This command has been deprecated, but is around for historical applications.
			Section 8.6 
		grep
			Command used ot print lines matching a specific pattern. grep searches the named input FILE for lines containing a match to a given PATTERN.
			Section 8.1 
		regex(7)
			Regular expression. This is a term used to describe a codified method of searching for text ,or other strings in text.
			Section 8.1 
		sed
			A non-interactive editor that can be used to modify text.
			| Section 8.4 

	}
}

chapter 9{

	# vi is a editor

	key terms{
		
		/, ?
			This is used to search for text while in command mode. the / is used to start searching. Enter a key term and press enter to begin searching the file for the text entered. If the user would like to search backwards in the document, a ? can be used instead of the /.
			Section 9.3 
		EDITOR

			Section 9.6 
		ZZ, :w!, :q!
			These keys are used to exit the vi editor from command mode. ZZ is used to save and quit the file. It must be done for each file. :w! will force the writing of the current file. :q! will exit the editor without saving changes to the current file.
			Section 9.5 
		d, p, y, dd, yy
			These are used to copy, replace and paste text when in command mode. d is used to cut one alphabetic word, where as dd is used to cut an entire line of text. y is used to copy one one alphabetic word, where as yy is used to copy and entire line at a time. If a number precedes either dd or yy, this will copy that number of lines. For example if 3dd is typed this will cut 3 lines at a time.
			Section 9.3 
		h,j,k,l
			These keys are used for basic cursor movement in vi when in command mode. h moves left one character, j moves down one line, k moves up one line, and l moves right one character.
			Section 9.2 
		i, o, a
			i, o, and a are used to enter insert mode from command mode. i will allow a user to start inserting text at the current location of the cursor. o will allow a user to start inserting text a line below the current location of the cursor, and a will allow a user to insert text one postion after the current location of the cursor.
			Section 9.4 
		vi
			A screen-oriented text editor originally created for Unix operating systems. vi is also known as a modal editor in which the user must switch modes to create, edit, and search text in a file.
			Section 9.1 | Section 9.2 | Section 9.3 | Section 9.4 | Section 9.5 

	}
}

chapter 10{
	key terms{
		
		tee
			Command used to read from standard input and write to standard output and files.
			Section 10.6 
		xargs
			Command used to build and execute command lines from standard input.
			Section 10.7 

	}
}


chapter 11{
	ps
	{ 
		ps[OPTION]...   # The ps command can be used to list processes
				# The ps command supports three styles of options{
					Traditonal UNIX style short options that use a single hyphens[-] in front of a character
					GNU style long options that use two hyphens[-] in front of a word
					BSD style options that use no hyphens[-] and single character options
				}
				# The ps command will display the processes that are running in the current terminal by default

			#ps Columns info{
				PID : The process identifier, witch is unique to the process. This info is useful to control the process by its ID number
				TTY : The name of the terminal ir pseudo-terminal where the process us running. This ifno is useful to distinguish between differebt processes that have the same name
				TIME : The total amount of processor time used by the process. Typically, this info int't used by regular users.
				CMD : The command that started the process.
			}

			# ps x [BSD option] state {
				D : Uninterruptible Sleep
				R : Running
				S : Interruptible Sleep
				T : Stopped
				Z : Zombie
			}

			# ps aux [BSD option] {
				a : Allows the ps command to show all processes
				u : Show processes by all users and ignore restrictions to only list the user's processes
				x : List all processes and remove the restriction to only display
			}# it shows everything

			in terminal{
				ps aux | grep -i sshd # To find all processes that match the sshd string
			}
	}

	pgrep
	{
		in terminal {
			pgrep -i sshd # If you wanted to find all instances of the sshd

			pgrep -li sshd # The output shows the process IDs (PID) of the processes running that match the sshd string. Additionally, the -l option can be used with the pgrep command to list the process name along with the PID

			# It is also possible to search for processes owned by a specific user by using the -u option

			pgrep -u sysadmin -l # the -u and -l options displayed the bash process which has the PID 56 and is owned by the sysadmin user.
		}

	}

	watch
	{
		syntax{ 
			watch [OPTION]... COMMAND
		}
		# The watch command can be use with date for a good test
		# The watch command can also be used with the ps command to monitor running processes in the shell
		in terminal {
			watch ps aux
		}
	}

	## To write a couple of command in one line use the semicolon [ ; ]


	Background Processes
	{
		COMMAND & 
		
		in terminal{
			sleep 3 & # this runs in the Background
		}
	}

	kill
	{
		syntax of kill command{
			kill [OPTION]... <pid>
		}

		### specifying signals for kill command {
			-<signal>
			-s <signal>
			--signal <signal>

			example for interrupt signal{
				-2
				-INT
				-SIGINT
			}
		}


		in terminal{
			kill -l # To see a list of all of the signals available for your system
 		}
		

		common signals{
			number : full name : short name : purpose
			1      : SIGHUB    :  HUP       : Hang up, usually ends a process
			2      : SIGINT    :  INT       : Interrupt, usually ends a process
			3      : SIGQUIT   :  QUIT      : Quit, usually ends a process
			9      : SIGKILL   :  KILL      : Kill, forcefully ends a process
			15     : SIGTERM   :  TERM      : Terminate, usually ends a process
			18     : SIGCONT   :  CONT      : Continue, resumes a stopped process
			19     : SIGSTOP   :  STOP      : Stop, forcefully stops a process
			20     : SIGTSTP   :  TSTP      : Terminal Stop, usually stops a process
		}
	}
	
	pkill{
		syntax{
			pkill [OPTION]... PATTERN
		}
		
		# the pkill command allows users to specify a pattern that matches a process name and then sends signals to that process
	}
	
	killall{
		syntax{
			killall [OPTION]... NAME
		}

		in terminal{
			killall sleep
		}

		# The killall command can also be used to terminate one or more processes by name and other criteria such as the user owner of the process and system processes.
	}

	# top is like the task manager

	key terms{ 
		&
			When used with a process will immediately background the process or task in a terminal. This will allow the terminal to be freed up for additional tasks.
			Section 11.2.6 

		bg
			A job control command that resumes the execution of a suspended process without bringing it to the foreground.
			Section 11.2.7 

		fg
			A job control command that resumes execution of a suspended process by bringing it to the foreground.
			Section 11.2.7 

		free
			Command used to display the amount of free and used memory in the system. This utility will display both the physical and swap memore on the system as well as the buffers used by the kernel.
			Section 11.2.3 | Section 11.3 

		jobs
			Command that lists all active jobs in the current terminal or shell.
			Section 11.2.6 

		kill
			Command used to terminate a process. There are specific signals that can terminate a process in different ways. If no signal is provided the TERM signal will be sent to the process.
			Section 11.2.8 

		killall
			Command similar to kill, but killall will allow a user to terminate a process by name as opposed to ID.
			Section 11.2.8 

		nice
			Command used to change the priority of a process. The higher the nice value the lower the priority of a process. Nice values range from -20 to 20.
			Section 11.2.10 

		nohup
			Command used to run a command immune to hangups, with output to a non-tty. If standard input is a terminal, it can be redirected from /dev/null. If standard output is the terminal, append the ouptput to nohup.out. This should be located in the user's home directory.
			Section 11.2.9 

		pgrep
			Command that parses through the running processes and looks for the specified names or other criteria of processes.
			Section 11.2.2 

		pkill
			Sends a specified signal (SIGTERM by default) to each process instead of listing them on stdout.
			Section 11.2.8 

		ps
			Command used to report a snapshot of the current processes. Different options are available with ps to report more specific information.
			Section 11.2.1 

		renice
			Command used to change the priority of a process while that process is running. The higher the value the lower the priority.
			Section 11.2.10 

		screen
			A full-screen software program that can be used to multiplex a physical console between several processes (typically interactive shells). It offers a user to open several separate terminal instances inside a one single terminal window manager. The screen application is very useful, if you are dealing with multiple programs from a command line interface and for separating programs from the terminal shell. It also allows you to share your sessions with others users and detach/attach terminal sessions.
			Section 11.4.1 

		tmux

			Section 11.4.2 

		top
			Command similar to ps, however top will display the curent real-time view of all running tasks and processes.
			Section 11.2.11 

		uptime
			Command that will display how long a system has been running. uptime gives a one line display showing the current time, how long ths system has been running, how many users are logged in, and the system load averages for the pas 1, 5 and 15 minutes.
			Section 11.3 
			
		watch

			Section 11.2.3 
	}

}


chapter 12{
	# Archiving: Combines multiple files into one, which eliminates the overhead in individual files and makes it easier to transmit.

	#Compression: Makes the files smaller by removing redundant information
	
	gzip and gunzip{
		# The gzip command is used to create a compressed file. Likewise, the gunzip command is used to view the contents of a compressed file, as well as extract those contents.
		
		syntax{
			gzip [OPTION]... [FILE]...
			gunzip [OPTION]... [FILE]...
		}

		# gzip2 compresses
		# gunzip2 uncompresses

		!!! The gzip command should be used with caution since its default behavior is to replace the original file specified with a compressed version.
	}

	zcat{
		# The zcat command is used to display the contents of a compressed file without actually uncompressing it

		syntax{
			zcat [OPTION]... [FILE]...
		}
	}

	bzip2 and bunzip2{
		#The bzip2 and bunzip2 commands work in a nearly identical fashion to the gzip and gunzip commands. However, while the gzip command uses the Lempel-Ziv data compression algorithm, the bzip utilities use a different compression algorithm called Burrows-Wheeler block sorting, that can compress files smaller than gzip at the expense of more CPU time
	
		syntax{
			bzip2 [OPTION]... [FILE]...
			bunzip2 [OPTION]... [FILE]...
		}

		# bzip2 compresses
		# bunzip2 uncompresses

		!!! The bzip2 command should be used with caution since its default behavior is to replace the original file specified with a compressed version.

		!!! ### -r recursion dose not work with bzip2 and bunzip2

		### The -v option gives a verbose output so you can see how the file was processed
	}

	bzcat{
		# The bzcat command prints the content of specified files compressed with the bzip2 command to the standard output.

		syntax{
			bzcat [OPTION]... [FILE]...
		}
	}

	xz and unxz{
		# Another archival tool similar to gzip and bzip2 is the xz command.
		### To compress a group of files individually, use the xz command with the -z option. Compression is the default operation mode, and therefore if the xz command is run with no options, the -z option is implied.

		syntax{
			xz [OPTION]... [FILE]...
		}

		### The -d option can be used with the xz command to uncompress the files just as easily

		# Another method of uncompressing files compressed using the xz command is to use the unxz command. Using unxz to uncompress a file is very similar to using gunzip because it uses similar syntax.
	
		!!! There are a huge number of options for the xz command, some relating to the compression ratio. Keep in mind when using xz that the more aggressive the compression, the harder the processor will have to work.
	}

	xzcat{
		# The xzcat command is used to print the contents of files compressed with the xz command to standard output on the terminal without uncompressing the target file.

		syntax{
			xzcat [FILE]...
		}
	}

	tar{
		## The tar command is typically used to make archives within Linux. These tar archive files, sometimes called tarballs, were originally used to backup data onto magnetic tape. Tar is derived from the words "tape archive".

		# While the primary purpose of the tar command is to merge multiple files into a single file, it is capable of many different operations, and there are numerous options

			tar functionalitys{
				
				### Create = -c # Make a new archive out of a series of files.

				### Extract = -x # Pull one or more files out of an archive.

				### List = -t # Show the contents of the archive without extracting.

			}

		Create Mode{

			syntax{
				tar -c [-f ARCHIVE] [OPTIONS] [FILE...]
			}

			### -c = create an archive.
			
			### -f ARCHIVE = Use the ARCHIVE file. The argument ARCHIVE will be the name of the resulting archive file.

			## All the remaining arguments, [FILE…], are considered as input file names either as a list of files, as a wildcard, or both.

			in terminal{
				tar -cf mydocuments.tar ~/Documents
			}
			
			### -v = Verbosely list the files processed.
			
			### -z = Compress (or decompress) the archive using the gzip command.

			### -j = Filter the archive through the bzip2 command

			### -J = Filter the archive through the xz command.

			## File extensions are not relevant to Linux; however, it is customary to add .tar.gz to the name of the compressed archive. 

			in terminal{
				tar -cvzf mydocuments.tar.gz ~/Documents
			}

		}

		List Mode{
			
			syntax{
				tar -t [-f ARCHIVE] [OPTIONS]
			}

			### -t = List the files in the archive. (table of contents)

			### -f ARCHIVE = Operate on the given archive. 

			in terminal{
				tar -tf mydocuments.tar.gz
			}

			## note that the -f option is used last so that the file name can be specified as an argument to this option

			in terminal{
				# you can add the verbose (-v) to get a more detailed output

				tar -tvf mydocuments.tar.gz
			}

		}

		Extract Mode{

			syntax{
				tar -x [-f ARCHIVE] [OPTIONS]
			}

			### -x = Extract files from an archive.

			### -f ARCHIVE = Operate on the given archive.

		}
	}

	zip and unzip{

		syntax{
			zip [OPTIONS]... [FILE]...
		}

		### One especially useful option for the zip command is the -r option, which allows the zip command to recursively compress

		# The unzip command is used to extract the files from the zip archive file. Use the unzip command without options to extract a zip archive

		### To view the contents of a zip file without unpacking it, use the unzip command with the list -l option:
	}

	cpio{
		## In copy-out mode, the cpio command will copy files from a directory into an archive.

		## In copy-out mode, the cpio command will copy files from a directory into an archive.

		## There is a third mode called the copy-pass mode. In this mode, the cpio command copies files from one directory to another, which combines the copy-out and copy-in modes without creating an archive file.
	
		Copy-Out Mode{
			### The -o option puts the cpio command into copy-out mode

			### Using the verbose -v option will cause the cpio command to list the files that it processes

			in terminal {
				ls | cpio -ov > archive.cpio
			}

			find command{

				in terminal{
					find . -depth -print | cpio -vo > /tmp/ar.cpio
				}

			}
		}

		Copy-In Mode{

			### To extract the files that are in a cpio archive, use the -i option with the cpio command to specify copy-in mode

			### By default, cpio will not overwrite existing files unless the -u option is used.

			!!! ### The cpio command will not create directories unless the -d option is used.

			in terminal{

				cpio -idv /tmp/test < /tmp/ar.cpio

				find ~ | cpio -pd /tmp/destination

			}

			## To specify the pass-through mode of the cpio command, specify the -p option. Again, if any directories are included, the -d option needs to be specified

			## To prevent problems with files that have white space characters (like the spacebar character) embedded in them, specify the -print0 option to the find command

			## For the cpio command to process the list of null separated files, add the --null option. This results in a more robust version of the previous pass-through command

			in terminal{
				find . -print0 | cpio --null -pvd /tmp/destination
			}

		}
	}

	dd{
		# The dd command is a utility for copying files or entire partitions at the bit level

		dd features{
			
			It can be used to clone or delete (wipe) entire disks or partitions.
			
			It can be used to copy raw data to removable devices, such as USB drives and CDROMs.
			
			It can backup and restore the MBR (Master Boot Record), a critical software component that is used to boot the system.
			
			It can be used to create a file of a specific size that is filled with binary zeros, which can then be used as a swap file (virtual memory).

		}

		dd commonly used special arguments{
			if=FILE : The input file to be read.
			of=FILE : The output file to be written.
			bs=SIZE : The block size to be used. By default, the value is considered to be in bytes. Use the following suffixes to specify other units: K, M, G, and T for kilobytes, megabytes, gigabytes, and terabytes respectively.
			count=NUMBERS : The number of blocks to read from the input file.
		}

		in terminal{
			# In the following example, a file named /tmp/swapex is created with 500 "one-megabyte" size blocks of zeros:

			dd if=/dev/zero of=/tmp/swapex bs=1M count=500
		}

	}

	key terms{
		
		bunzip2
			Command that uncompresses files compressed using the <command>bzip2</command> command and removes the .bz2 extension.
			Section 12.4 
		bzcat
			Command prints the content of specified files compressed with the <command>bzip2</command> command to the standard output.
			Section 12.5 
		gunzip
			Command that decompress files created by gzip, zip, compress, compress -H or pack.
			Section 12.2 
		gzip
			Command used to comperess or expand files. Gzip reduces the size of the named files using Lempel-Ziv coding (LZ77). Whenever possible, each file is replaced by one with the extension .gz, while keeping the same ownership modes, access and modification times. (The default extension is -gz for VMS, z for MSDOS, OS/2 FAT, Windows NT FAT and Atari.)
			Section 12.2 
		unxz
			A method of uncompressing files compressed using the <command>xz</command> command.
			Section 12.6 
		xz
			Command that can compress or decompress .zx or .lzma files. xz is a general-purpose data compression tool with command line syntax similar to gzip(1) and bzip2(1). The native file format is the .xz format, but also the legacy .lzma format and raw compressed streams with no container format headers are supported.
			Section 12.6 
		xzcat
			Command used to print the contents of files compressed with the <command>xz</command> command to standard output on the terminal without uncompressing the target file.
			Section 12.7 
		zcat
			Command used to display the contents of a compressed file from a compressed archive created by the <command>tar</command> or <command>gzip</command> commands without uncompressing it. Its effect is identical to running the <command>gzip -c</command> command:
			Section 12.3 

	}
}



chapter 13 and 14{

	File Type Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
		^
	}

	Permissions Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
		 ^^^^^^^^^
	}

	User Owner Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
			      ^^^^
	}

	Group Owner Field{
		-rwxr-xr-x. 1 root root 133792 Jan  18  2018 /bin/ls
				   ^^^^
	}

	Switching Users{
		
		!!! ## By default, if a username is not specified, the su command opens a new shell as the root user. The following two commands are equivalent ways to start a shell as the root user:

		syntax{
			su [OPTIONS] [USERNAME]
		}

		login shell{
			# When switching users, utilizing the login shell option is recommended as the login shell fully configures the new shell with the settings of the new user, ensuring any commands executed run correctly. If this option is omitted, the new shell changes the UID but doesn't fully log in as the user
		
			The login shell option can be specified one of three ways:{

				in terminal{

					su -
					su -l
					su --login

				}

			}
		}

		sudo{
			
			syntax{
				sudo [OPTIONS] COMMAND
			}

		}
	}

	Changing File User Owner{

		## Initially, the owner of a file is the user who creates it. The user owner can only be changed by a user with root privileges using the chown command

		syntax{
			chown [OPTION]... [OWNER] FILE..
		}
	}

	Switching Groups{
		## To create a file or directory that will be owned by a group different from your current primary group, one option is to change your current primary group to another group you belong to by using the newgrp command.

		syntax{
			newgrp [GROUP]
		}

		## Once in the new shell, any file created, in this case, newfile.txt, will belong to the new primary group
	}

	Changing File Group Owner{

		## Another option is for the user owner of the file to change the group owner by using the chgrp command. For example, if you forgot to use the newgrp command to switch to the user’s primary group before creating the file.
	}

	chmod{
		symbol method{
			
			# + = - u = user, g = group, o = other, a = all

			# r = read
			# w = write
			# x = execute

		}

		in terminal {
			touch permissions.txt

			chmod g-r permissions.txt # minus read from group
			chmod g+r permissions.txt # add read to group

			chmod u+w permissions.txt # add write to user

			chmod o=w,g-r,u+x permissions.txt # other = write, group - read, user add execute

			chmod a=- permissions.txt # clear all permissions
		} 
		octal method{
			
			read( r ) = 4
			write( w ) = 2
			execute( x ) = 1
			none = 0
			
		}

		in terminal{
			chmod 765 permissions.txt # adding read, write and execute

			chmod 000 permissions.txt # clear all permissions

			# chmod user,group,other permissions.txt
		}


		more about octal method{
			7 : rwx
			6 : rw-
			5 : r-x
			4 : r--
			3 : -wx
			2 : -w-
			1 : --x
			0 : ---
		}

		setuid{
			# When the setuid permission is set on an executable binary file (a program), the binary file is run as the owner of the file, not as the user who executed it. This permission is set on a handful of system utilities so that they can be run by normal users, but executed with the permissions of root, providing access to system files that the normal user doesn't normally have access to.

			in terminal symbolically{

				add{
					chmod u+s file
				}

				remove{
					chmod u-s file
				}

			}

			in terminal octal{
				
				add{
					chmod 4000 file
				}

				remove{
					chmod 0000 file
				}
			}

			## Permission with the octal method using three-digit codes. When a three-digit code is provided, the chmod command assumes that the first digit before the three-digit code is 0. Only when four digits are specified is a special permission set.
			## If three digits are specified when changing the permissions on a file that already has a special permission set, the first digit will be set to 0, and the special permission will be removed from the file.
		}

		setgid{
			# The setgid permission is similar to setuid, but it makes use of the group owner permissions. There are two forms of setgid permissions: setgid on a file and setgid on a directory. The behavior of setgid depends on whether it is set on a file or directory.
			# The setgid permission on a file works very similarly to the setuid permission, except that instead of executing as the user who owns the file, setgid permission will execute as the group that owns the file. The system allows the user running the command to effectively belong to the group that owns the file, but only in the setgid program.
		
			in terminal symbolically{
				
				add{
					chmod g+s <file|directory>
				}

				remove{
					chmod g-s <file|directory>
				}
			}

			in terminal octal{
				
				add{
					chmod 2000 <file|directory>
				}

				remove{
					chmod 0000 <file|directory>
				}
			}

		}

		Sticky Bit{
			# Setting this permission can be important to prevent users from deleting other user's files.

			in terminal symbolically{
				
				add{
					chmod o+t <directory>
				}
				
				remove{
					chmod o-t <directory>
				}
			}

			in terminal octal{
				
				add{
					chmod 1000 <file|directory>
				}

				remove{
					chmod 0000 <file|directory>
				}
			}
		}

		special Sticky + setgid{
			
			in terminal{
				chmod 3770 <file>

				output{
					drwxrws--T. 2 <user> <group> 4096 Jan 10 09:08 <file>
				}
			}

			## Notice that the special permissions of setgid and sticky bit can be added together, the 2000 permission plus the 1000 permission gives you 3000 for the special permissions. Add this to the basic permissions for the user, group, and others; The owner and group have full access, and others get none.
		
			## The uppercase T in the execute permission position for others indicates there is no execute permission for others. However, since multiple users of the group still have access, the sticky permission is effective for the group.
		}
	}

	key terms for chapter 13{
		
		chgrp
			Command that is used to change the primary group of a file. Essentially it changes what group is the owner of the FILE.
			Section 13.2.4 
		chmod
			Command that is used to change the mode bits of a FILE. The chmod utility can be used to change the files permissions. For example setting the read, write, and execute bits.
			Section 13.4 
		chown
			Command that is used to change the ownership of a FILE. The chown utility can also be used to change the primary group of a FILE as well.
			Section 13.2.2 
		umask
			Command that sets the calling process's file mode creation mask. The umask utility will set the default permissions for FILEs when they are created.
			Section 13.7 


	}

	-------------- chapter 14 begining ----------------------------------------------------------------------------------------------------------------------------------------------

	users{
		sudo adduser **name** # create user

		cat /etc/passwd | grep ^**name** # to loced user
	}

	df -i # Inodes table


	links{
		in terminal{
			touch file.txt file1.txt
		}

		hardlink{
			
			syntax{
				ln TARGET LINK_NAME
				## To create hard links, the ln command is used with two arguments (and without the -s option). The first argument is an existing file name to link to, called a target, and the second argument is the new file name to link to the target.
			}

			in terminal{
				ln file.txt hardlink_to_file.txt # using hardlink to link to file.txt
			}

			filename, incode{
				passwd : 123
				shadow : 175
				group : 144
				gshadow : 897
			}

		}

		softlinks{
			
			syntax{
				ln -s TARGET LINK_NAME
			}

			in terminal{
				ln -s file1.txt symlink_to_file1.txt # -s for softlinks this is a symbolicklink, Softlinks(symbolicklinks) can be used like shortcuts linking a file to another file
			}

		}


		ls -li # see everything with Inodes numbers
	}
}
